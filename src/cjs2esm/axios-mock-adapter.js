import _axios2 from "./axios.js";
import _axios from "./axios.js";
var module = {
  exports: {}
};
var exports = module.exports;

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(_axios);else if (typeof define === 'function' && define.amd) define(["axios"], factory);else if (typeof exports === 'object') exports["AxiosMockAdapter"] = factory(_axios2);else root["AxiosMockAdapter"] = factory(root["axios"]);
})(self, __WEBPACK_EXTERNAL_MODULE_axios__ => {
  return (
    /******/
    (() => {
      // webpackBootstrap

      /******/
      var __webpack_modules__ = {
        /***/
        "./node_modules/fast-deep-equal/index.js":
        /*!***********************************************!*\
          !*** ./node_modules/fast-deep-equal/index.js ***!
          \***********************************************/

        /***/
        module => {
          "use strict";

          eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n\n//# sourceURL=webpack://AxiosMockAdapter/./node_modules/fast-deep-equal/index.js?");
          /***/
        },

        /***/
        "./node_modules/is-buffer/index.js":
        /*!*****************************************!*\
          !*** ./node_modules/is-buffer/index.js ***!
          \*****************************************/

        /***/
        module => {
          eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n\n//# sourceURL=webpack://AxiosMockAdapter/./node_modules/is-buffer/index.js?");
          /***/
        },

        /***/
        "./src/handle_request.js":
        /*!*******************************!*\
          !*** ./src/handle_request.js ***!
          \*******************************/

        /***/
        (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";

          eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nfunction transformRequest(data) {\n  if (\n    utils.isArrayBuffer(data) ||\n    utils.isBuffer(data) ||\n    utils.isStream(data) ||\n    utils.isBlob(data)\n  ) {\n    return data;\n  }\n\n  // Object and Array: returns a deep copy\n  if (utils.isObjectOrArray(data)) {\n    return JSON.parse(JSON.stringify(data));\n  }\n\n  // for primitives like string, undefined, null, number\n  return data;\n}\n\nfunction makeResponse(result, config) {\n  return {\n    status: result[0],\n    data: transformRequest(result[1]),\n    headers: result[2],\n    config: config,\n    request: {\n      responseURL: config.url,\n    },\n  };\n}\n\nfunction passThroughRequest (mockAdapter, resolve, reject, config) {\n  // Axios v0.17 mutates the url to include the baseURL for non hostnames\n  // but does not remove the baseURL from the config\n  var baseURL = config.baseURL;\n  if (config.baseURL && !/^https?:/.test(config.baseURL)) {\n    baseURL = undefined;\n  }\n\n  // Axios pre 1.2\n  if (typeof mockAdapter.originalAdapter === 'function') {\n    return mockAdapter.originalAdapter(config).then(resolve, reject);\n  }\n\n  mockAdapter.axiosInstanceWithoutInterceptors(Object.assign({}, config, {\n    baseURL: baseURL,\n    //  Use the original adapter, not the mock adapter\n    adapter: mockAdapter.originalAdapter,\n    // The request transformation runs on the original axios handler already\n    transformRequest: [],\n    transformResponse: []\n  })).then(resolve, reject);\n}\n\nfunction handleRequest(mockAdapter, resolve, reject, config) {\n  var url = config.url || \"\";\n  // TODO we're not hitting this `if` in any of the tests, investigate\n  if (\n    config.baseURL &&\n    url.substr(0, config.baseURL.length) === config.baseURL\n  ) {\n    url = url.slice(config.baseURL.length);\n  }\n\n  delete config.adapter;\n  mockAdapter.history[config.method].push(config);\n\n  var handler = utils.findHandler(\n    mockAdapter.handlers,\n    config.method,\n    url,\n    config.data,\n    config.params,\n    (config.headers && config.headers.constructor.name === 'AxiosHeaders')\n      ? Object.assign({}, config.headers)\n      : config.headers,\n    config.baseURL\n  );\n\n  if (handler) {\n    if (handler.length === 7) {\n      utils.purgeIfReplyOnce(mockAdapter, handler);\n    }\n\n    if (handler.length === 2) {\n      // passThrough handler\n      passThroughRequest(mockAdapter, resolve, reject, config);\n    } else if (typeof handler[3] !== \"function\") {\n      utils.settle(\n        resolve,\n        reject,\n        makeResponse(handler.slice(3), config),\n        mockAdapter.delayResponse\n      );\n    } else {\n      var result = handler[3](config);\n      // TODO throw a sane exception when return value is incorrect\n      if (typeof result.then !== \"function\") {\n        utils.settle(\n          resolve,\n          reject,\n          makeResponse(result, config),\n          mockAdapter.delayResponse\n        );\n      } else {\n        result.then(\n          function (result) {\n            if (result.config && result.status) {\n              utils.settle(\n                resolve,\n                reject,\n                makeResponse(\n                  [result.status, result.data, result.headers],\n                  result.config\n                ),\n                0\n              );\n            } else {\n              utils.settle(\n                resolve,\n                reject,\n                makeResponse(result, config),\n                mockAdapter.delayResponse\n              );\n            }\n          },\n          function (error) {\n            if (mockAdapter.delayResponse > 0) {\n              setTimeout(function () {\n                reject(error);\n              }, mockAdapter.delayResponse);\n            } else {\n              reject(error);\n            }\n          }\n        );\n      }\n    }\n  } else {\n    // handler not found\n    switch (mockAdapter.onNoMatch) {\n      case \"passthrough\":\n        passThroughRequest(mockAdapter, resolve, reject, config);\n        break;\n      case \"throwException\":\n        throw utils.createCouldNotFindMockError(config);\n      default:\n        utils.settle(\n          resolve,\n          reject,\n          {\n            status: 404,\n            config: config,\n          },\n          mockAdapter.delayResponse\n        );\n    }\n  }\n}\n\nmodule.exports = handleRequest;\n\n\n//# sourceURL=webpack://AxiosMockAdapter/./src/handle_request.js?");
          /***/
        },

        /***/
        "./src/index.js":
        /*!**********************!*\
          !*** ./src/index.js ***!
          \**********************/

        /***/
        (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";

          eval("\n\nvar handleRequest = __webpack_require__(/*! ./handle_request */ \"./src/handle_request.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nvar VERBS = [\n  \"get\",\n  \"post\",\n  \"head\",\n  \"delete\",\n  \"patch\",\n  \"put\",\n  \"options\",\n  \"list\",\n  \"link\",\n  \"unlink\",\n];\n\nfunction adapter() {\n  return function (config) {\n    var mockAdapter = this;\n    return new Promise(function (resolve, reject) {\n      handleRequest(mockAdapter, resolve, reject, config);\n    });\n  }.bind(this);\n}\n\nfunction getVerbObject() {\n  return VERBS.reduce(function (accumulator, verb) {\n    accumulator[verb] = [];\n    return accumulator;\n  }, {});\n}\n\nfunction reset() {\n  resetHandlers.call(this);\n  resetHistory.call(this);\n}\n\nfunction resetHandlers() {\n  this.handlers = getVerbObject();\n}\n\nfunction resetHistory() {\n  this.history = getVerbObject();\n}\n\nfunction MockAdapter(axiosInstance, options) {\n  reset.call(this);\n\n  if (axiosInstance) {\n    this.axiosInstance = axiosInstance;\n    // Clone the axios instance to remove interceptors\n    // this is used for the passThrough mode with axios > 1.2\n    this.axiosInstanceWithoutInterceptors = axiosInstance.create\n      ? axiosInstance.create()\n      : undefined;\n\n    this.originalAdapter = axiosInstance.defaults.adapter;\n    this.delayResponse =\n      options && options.delayResponse > 0 ? options.delayResponse : null;\n    this.onNoMatch = (options && options.onNoMatch) || null;\n    axiosInstance.defaults.adapter = this.adapter.call(this);\n  } else {\n    throw new Error(\"Please provide an instance of axios to mock\");\n  }\n}\n\nMockAdapter.prototype.adapter = adapter;\n\nMockAdapter.prototype.restore = function restore() {\n  if (this.axiosInstance) {\n    this.axiosInstance.defaults.adapter = this.originalAdapter;\n    this.axiosInstance = undefined;\n  }\n};\n\nMockAdapter.prototype.reset = reset;\nMockAdapter.prototype.resetHandlers = resetHandlers;\nMockAdapter.prototype.resetHistory = resetHistory;\n\nVERBS.concat(\"any\").forEach(function (method) {\n  var methodName = \"on\" + method.charAt(0).toUpperCase() + method.slice(1);\n  MockAdapter.prototype[methodName] = function (matcher, body, requestHeaders) {\n    var _this = this;\n    var matcher = matcher === undefined ? /.*/ : matcher;\n\n    function reply(code, response, headers) {\n      var handler = [matcher, body, requestHeaders, code, response, headers];\n      addHandler(method, _this.handlers, handler);\n      return _this;\n    }\n\n    function replyOnce(code, response, headers) {\n      var handler = [\n        matcher,\n        body,\n        requestHeaders,\n        code,\n        response,\n        headers,\n        true,\n      ];\n      addHandler(method, _this.handlers, handler);\n      return _this;\n    }\n\n    return {\n      reply: reply,\n\n      replyOnce: replyOnce,\n\n      passThrough: function passThrough() {\n        var handler = [matcher, body];\n        addHandler(method, _this.handlers, handler);\n        return _this;\n      },\n\n      abortRequest: function () {\n        return reply(function (config) {\n          var error = utils.createAxiosError(\n            \"Request aborted\",\n            config,\n            undefined,\n            \"ECONNABORTED\"\n          );\n          return Promise.reject(error);\n        });\n      },\n\n      abortRequestOnce: function () {\n        return replyOnce(function (config) {\n          var error = utils.createAxiosError(\n            \"Request aborted\",\n            config,\n            undefined,\n            \"ECONNABORTED\"\n          );\n          return Promise.reject(error);\n        });\n      },\n\n      networkError: function () {\n        return reply(function (config) {\n          var error = utils.createAxiosError(\"Network Error\", config);\n          return Promise.reject(error);\n        });\n      },\n\n      networkErrorOnce: function () {\n        return replyOnce(function (config) {\n          var error = utils.createAxiosError(\"Network Error\", config);\n          return Promise.reject(error);\n        });\n      },\n\n      timeout: function () {\n        return reply(function (config) {\n          var error = utils.createAxiosError(\n            config.timeoutErrorMessage ||\n              \"timeout of \" + config.timeout + \"ms exceeded\",\n            config,\n            undefined,\n            \"ECONNABORTED\"\n          );\n          return Promise.reject(error);\n        });\n      },\n\n      timeoutOnce: function () {\n        return replyOnce(function (config) {\n          var error = utils.createAxiosError(\n            config.timeoutErrorMessage ||\n              \"timeout of \" + config.timeout + \"ms exceeded\",\n            config,\n            undefined,\n            \"ECONNABORTED\"\n          );\n          return Promise.reject(error);\n        });\n      },\n    };\n  };\n});\n\nfunction findInHandlers(method, handlers, handler) {\n  var index = -1;\n  for (var i = 0; i < handlers[method].length; i += 1) {\n    var item = handlers[method][i];\n    var isReplyOnce = item.length === 7;\n    var comparePaths =\n      item[0] instanceof RegExp && handler[0] instanceof RegExp\n        ? String(item[0]) === String(handler[0])\n        : item[0] === handler[0];\n    var isSame =\n      comparePaths &&\n      utils.isEqual(item[1], handler[1]) &&\n      utils.isEqual(item[2], handler[2]);\n    if (isSame && !isReplyOnce) {\n      index = i;\n    }\n  }\n  return index;\n}\n\nfunction addHandler(method, handlers, handler) {\n  if (method === \"any\") {\n    VERBS.forEach(function (verb) {\n      handlers[verb].push(handler);\n    });\n  } else {\n    var indexOfExistingHandler = findInHandlers(method, handlers, handler);\n    if (indexOfExistingHandler > -1 && handler.length < 7) {\n      handlers[method].splice(indexOfExistingHandler, 1, handler);\n    } else {\n      handlers[method].push(handler);\n    }\n  }\n}\n\nmodule.exports = MockAdapter;\nmodule.exports[\"default\"] = MockAdapter;\n\n\n//# sourceURL=webpack://AxiosMockAdapter/./src/index.js?");
          /***/
        },

        /***/
        "./src/is_blob.js":
        /*!************************!*\
          !*** ./src/is_blob.js ***!
          \************************/

        /***/
        module => {
          eval("/*!\n * MIT License\n *\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nfunction isBlob(value) {\n  if (typeof Blob === 'undefined') {\n    return false;\n  }\n\n  return value instanceof Blob || Object.prototype.toString.call(value) === '[object Blob]';\n}\n\nmodule.exports = isBlob;\n\n\n//# sourceURL=webpack://AxiosMockAdapter/./src/is_blob.js?");
          /***/
        },

        /***/
        "./src/utils.js":
        /*!**********************!*\
          !*** ./src/utils.js ***!
          \**********************/

        /***/
        (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";

          eval("\n\nvar axios = __webpack_require__(/*! axios */ \"axios\");\nvar isEqual = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\");\nvar isBlob = __webpack_require__(/*! ./is_blob */ \"./src/is_blob.js\");\nvar toString = Object.prototype.toString;\n\nfunction find(array, predicate) {\n  var length = array.length;\n  for (var i = 0; i < length; i++) {\n    var value = array[i];\n    if (predicate(value)) return value;\n  }\n}\n\nfunction isFunction(val) {\n  return toString.call(val) === \"[object Function]\";\n}\n\nfunction isObjectOrArray(val) {\n  return val !== null && typeof val === \"object\";\n}\n\nfunction isStream(val) {\n  return isObjectOrArray(val) && isFunction(val.pipe);\n}\n\nfunction isArrayBuffer(val) {\n  return toString.call(val) === \"[object ArrayBuffer]\";\n}\n\nfunction combineUrls(baseURL, url) {\n  if (baseURL) {\n    return baseURL.replace(/\\/+$/, \"\") + \"/\" + url.replace(/^\\/+/, \"\");\n  }\n\n  return url;\n}\n\nfunction findHandler(\n  handlers,\n  method,\n  url,\n  body,\n  parameters,\n  headers,\n  baseURL\n) {\n  return find(handlers[method.toLowerCase()], function (handler) {\n    if (typeof handler[0] === \"string\") {\n      return (\n        (isUrlMatching(url, handler[0]) ||\n          isUrlMatching(combineUrls(baseURL, url), handler[0])) &&\n        isBodyOrParametersMatching(method, body, parameters, handler[1]) &&\n        isObjectMatching(headers, handler[2])\n      );\n    } else if (handler[0] instanceof RegExp) {\n      return (\n        (handler[0].test(url) || handler[0].test(combineUrls(baseURL, url))) &&\n        isBodyOrParametersMatching(method, body, parameters, handler[1]) &&\n        isObjectMatching(headers, handler[2])\n      );\n    }\n  });\n}\n\nfunction isUrlMatching(url, required) {\n  var noSlashUrl = url[0] === \"/\" ? url.substr(1) : url;\n  var noSlashRequired = required[0] === \"/\" ? required.substr(1) : required;\n  return noSlashUrl === noSlashRequired;\n}\n\nfunction isBodyOrParametersMatching(method, body, parameters, required) {\n  var allowedParamsMethods = [\"delete\", \"get\", \"head\", \"options\"];\n  if (allowedParamsMethods.indexOf(method.toLowerCase()) >= 0) {\n    var data = required ? required.data : undefined;\n    var params = required ? required.params : undefined;\n    return isObjectMatching(parameters, params) && isBodyMatching(body, data);\n  } else {\n    return isBodyMatching(body, required);\n  }\n}\n\nfunction isObjectMatching(actual, expected) {\n  if (expected === undefined) return true;\n  if (typeof expected.asymmetricMatch === \"function\") {\n    return expected.asymmetricMatch(actual);\n  }\n  return isEqual(actual, expected);\n}\n\nfunction isBodyMatching(body, requiredBody) {\n  if (requiredBody === undefined) {\n    return true;\n  }\n  var parsedBody;\n  try {\n    parsedBody = JSON.parse(body);\n  } catch (e) {}\n\n  return isObjectMatching(parsedBody ? parsedBody : body, requiredBody);\n}\n\nfunction purgeIfReplyOnce(mock, handler) {\n  Object.keys(mock.handlers).forEach(function (key) {\n    var index = mock.handlers[key].indexOf(handler);\n    if (index > -1) {\n      mock.handlers[key].splice(index, 1);\n    }\n  });\n}\n\nfunction settle(resolve, reject, response, delay) {\n  if (delay > 0) {\n    setTimeout(settle, delay, resolve, reject, response);\n    return;\n  }\n\n  if (\n    !response.config.validateStatus ||\n    response.config.validateStatus(response.status)\n  ) {\n    resolve(response);\n  } else {\n    reject(\n      createAxiosError(\n        \"Request failed with status code \" + response.status,\n        response.config,\n        response\n      )\n    );\n  }\n}\n\nfunction createAxiosError(message, config, response, code) {\n  // axios v0.27.0+ defines AxiosError as constructor\n  if (typeof axios.AxiosError === \"function\") {\n    return axios.AxiosError.from(new Error(message), code, config, null, response);\n  }\n\n  // handling for axios v0.26.1 and below\n  var error = new Error(message);\n  error.isAxiosError = true;\n  error.config = config;\n  if (response !== undefined) {\n    error.response = response;\n  }\n  if (code !== undefined) {\n    error.code = code;\n  }\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n    };\n  };\n  return error;\n}\n\nfunction createCouldNotFindMockError(config) {\n  var message =\n    \"Could not find mock for: \\n\" +\n    JSON.stringify(config, [\"method\", \"url\"], 2);\n  var error = new Error(message);\n  error.isCouldNotFindMockError = true;\n  error.url = config.url;\n  error.method = config.method;\n  return error;\n}\n\nmodule.exports = {\n  find: find,\n  findHandler: findHandler,\n  purgeIfReplyOnce: purgeIfReplyOnce,\n  settle: settle,\n  isStream: isStream,\n  isArrayBuffer: isArrayBuffer,\n  isFunction: isFunction,\n  isObjectOrArray: isObjectOrArray,\n  isBuffer: isBuffer,\n  isBlob: isBlob,\n  isBodyOrParametersMatching: isBodyOrParametersMatching,\n  isEqual: isEqual,\n  createAxiosError: createAxiosError,\n  createCouldNotFindMockError: createCouldNotFindMockError,\n};\n\n\n//# sourceURL=webpack://AxiosMockAdapter/./src/utils.js?");
          /***/
        },

        /***/
        "axios":
        /*!************************!*\
          !*** external "axios" ***!
          \************************/

        /***/
        module => {
          "use strict";

          module.exports = __WEBPACK_EXTERNAL_MODULE_axios__;
          /***/
        }
        /******/

      };
      /************************************************************************/

      /******/
      // The module cache

      /******/

      var __webpack_module_cache__ = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/
        // Check if module is in cache

        /******/
        var cachedModule = __webpack_module_cache__[moduleId];
        /******/

        if (cachedModule !== undefined) {
          /******/
          return cachedModule.exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed

          /******/
          // no module.loaded needed

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/

        /******/
        // Return the exports of the module

        /******/


        return module.exports;
        /******/
      }
      /******/

      /************************************************************************/

      /******/

      /******/
      // startup

      /******/
      // Load entry module and return exports

      /******/
      // This entry module is referenced by other modules so it can't be inlined

      /******/


      var __webpack_exports__ = __webpack_require__("./src/index.js");
      /******/

      /******/


      return __webpack_exports__;
      /******/
    })()
  );
});

export default module.exports;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXhpb3MtbW9jay1hZGFwdGVyLmpzIiwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJzZWxmIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9heGlvc19fIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsImV2YWwiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJ1bmRlZmluZWQiLCJfX3dlYnBhY2tfZXhwb3J0c19fIl0sInNvdXJjZXMiOlsiLi4vLi4vbm9kZV9tb2R1bGVzL2F4aW9zLW1vY2stYWRhcHRlci9kaXN0L2F4aW9zLW1vY2stYWRhcHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQVRURU5USU9OOiBUaGUgXCJldmFsXCIgZGV2dG9vbCBoYXMgYmVlbiB1c2VkIChtYXliZSBieSBkZWZhdWx0IGluIG1vZGU6IFwiZGV2ZWxvcG1lbnRcIikuXG4gKiBUaGlzIGRldnRvb2wgaXMgbmVpdGhlciBtYWRlIGZvciBwcm9kdWN0aW9uIG5vciBmb3IgcmVhZGFibGUgb3V0cHV0IGZpbGVzLlxuICogSXQgdXNlcyBcImV2YWwoKVwiIGNhbGxzIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHNvdXJjZSBmaWxlIGluIHRoZSBicm93c2VyIGRldnRvb2xzLlxuICogSWYgeW91IGFyZSB0cnlpbmcgdG8gcmVhZCB0aGUgb3V0cHV0IGZpbGUsIHNlbGVjdCBhIGRpZmZlcmVudCBkZXZ0b29sIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vZGV2dG9vbC8pXG4gKiBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IGRldnRvb2wgd2l0aCBcImRldnRvb2w6IGZhbHNlXCIuXG4gKiBJZiB5b3UgYXJlIGxvb2tpbmcgZm9yIHByb2R1Y3Rpb24tcmVhZHkgb3V0cHV0IGZpbGVzLCBzZWUgbW9kZTogXCJwcm9kdWN0aW9uXCIgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9tb2RlLykuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImF4aW9zXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImF4aW9zXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkF4aW9zTW9ja0FkYXB0ZXJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJheGlvc1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiQXhpb3NNb2NrQWRhcHRlclwiXSA9IGZhY3Rvcnkocm9vdFtcImF4aW9zXCJdKTtcbn0pKHNlbGYsIChfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2F4aW9zX18pID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcXG5cXG5cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcXG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcXG5cXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcXG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcXG5cXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcXG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XFxuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuXFxuXFxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcXG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xcblxcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XFxuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcXG5cXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XFxuXFxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xcblxcbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcXG4gIHJldHVybiBhIT09YSAmJiBiIT09YjtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0F4aW9zTW9ja0FkYXB0ZXIvLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qIVxcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcXG4gKlxcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XFxuICogQGxpY2Vuc2UgIE1JVFxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmXFxuICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQXhpb3NNb2NrQWRhcHRlci8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9oYW5kbGVfcmVxdWVzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9oYW5kbGVfcmVxdWVzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscyAqLyBcXFwiLi9zcmMvdXRpbHMuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEpIHtcXG4gIGlmIChcXG4gICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxcbiAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxcbiAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxcbiAgICB1dGlscy5pc0Jsb2IoZGF0YSlcXG4gICkge1xcbiAgICByZXR1cm4gZGF0YTtcXG4gIH1cXG5cXG4gIC8vIE9iamVjdCBhbmQgQXJyYXk6IHJldHVybnMgYSBkZWVwIGNvcHlcXG4gIGlmICh1dGlscy5pc09iamVjdE9yQXJyYXkoZGF0YSkpIHtcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xcbiAgfVxcblxcbiAgLy8gZm9yIHByaW1pdGl2ZXMgbGlrZSBzdHJpbmcsIHVuZGVmaW5lZCwgbnVsbCwgbnVtYmVyXFxuICByZXR1cm4gZGF0YTtcXG59XFxuXFxuZnVuY3Rpb24gbWFrZVJlc3BvbnNlKHJlc3VsdCwgY29uZmlnKSB7XFxuICByZXR1cm4ge1xcbiAgICBzdGF0dXM6IHJlc3VsdFswXSxcXG4gICAgZGF0YTogdHJhbnNmb3JtUmVxdWVzdChyZXN1bHRbMV0pLFxcbiAgICBoZWFkZXJzOiByZXN1bHRbMl0sXFxuICAgIGNvbmZpZzogY29uZmlnLFxcbiAgICByZXF1ZXN0OiB7XFxuICAgICAgcmVzcG9uc2VVUkw6IGNvbmZpZy51cmwsXFxuICAgIH0sXFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFJlcXVlc3QgKG1vY2tBZGFwdGVyLCByZXNvbHZlLCByZWplY3QsIGNvbmZpZykge1xcbiAgLy8gQXhpb3MgdjAuMTcgbXV0YXRlcyB0aGUgdXJsIHRvIGluY2x1ZGUgdGhlIGJhc2VVUkwgZm9yIG5vbiBob3N0bmFtZXNcXG4gIC8vIGJ1dCBkb2VzIG5vdCByZW1vdmUgdGhlIGJhc2VVUkwgZnJvbSB0aGUgY29uZmlnXFxuICB2YXIgYmFzZVVSTCA9IGNvbmZpZy5iYXNlVVJMO1xcbiAgaWYgKGNvbmZpZy5iYXNlVVJMICYmICEvXmh0dHBzPzovLnRlc3QoY29uZmlnLmJhc2VVUkwpKSB7XFxuICAgIGJhc2VVUkwgPSB1bmRlZmluZWQ7XFxuICB9XFxuXFxuICAvLyBBeGlvcyBwcmUgMS4yXFxuICBpZiAodHlwZW9mIG1vY2tBZGFwdGVyLm9yaWdpbmFsQWRhcHRlciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICByZXR1cm4gbW9ja0FkYXB0ZXIub3JpZ2luYWxBZGFwdGVyKGNvbmZpZykudGhlbihyZXNvbHZlLCByZWplY3QpO1xcbiAgfVxcblxcbiAgbW9ja0FkYXB0ZXIuYXhpb3NJbnN0YW5jZVdpdGhvdXRJbnRlcmNlcHRvcnMoT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7XFxuICAgIGJhc2VVUkw6IGJhc2VVUkwsXFxuICAgIC8vICBVc2UgdGhlIG9yaWdpbmFsIGFkYXB0ZXIsIG5vdCB0aGUgbW9jayBhZGFwdGVyXFxuICAgIGFkYXB0ZXI6IG1vY2tBZGFwdGVyLm9yaWdpbmFsQWRhcHRlcixcXG4gICAgLy8gVGhlIHJlcXVlc3QgdHJhbnNmb3JtYXRpb24gcnVucyBvbiB0aGUgb3JpZ2luYWwgYXhpb3MgaGFuZGxlciBhbHJlYWR5XFxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IFtdLFxcbiAgICB0cmFuc2Zvcm1SZXNwb25zZTogW11cXG4gIH0pKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XFxufVxcblxcbmZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QobW9ja0FkYXB0ZXIsIHJlc29sdmUsIHJlamVjdCwgY29uZmlnKSB7XFxuICB2YXIgdXJsID0gY29uZmlnLnVybCB8fCBcXFwiXFxcIjtcXG4gIC8vIFRPRE8gd2UncmUgbm90IGhpdHRpbmcgdGhpcyBgaWZgIGluIGFueSBvZiB0aGUgdGVzdHMsIGludmVzdGlnYXRlXFxuICBpZiAoXFxuICAgIGNvbmZpZy5iYXNlVVJMICYmXFxuICAgIHVybC5zdWJzdHIoMCwgY29uZmlnLmJhc2VVUkwubGVuZ3RoKSA9PT0gY29uZmlnLmJhc2VVUkxcXG4gICkge1xcbiAgICB1cmwgPSB1cmwuc2xpY2UoY29uZmlnLmJhc2VVUkwubGVuZ3RoKTtcXG4gIH1cXG5cXG4gIGRlbGV0ZSBjb25maWcuYWRhcHRlcjtcXG4gIG1vY2tBZGFwdGVyLmhpc3RvcnlbY29uZmlnLm1ldGhvZF0ucHVzaChjb25maWcpO1xcblxcbiAgdmFyIGhhbmRsZXIgPSB1dGlscy5maW5kSGFuZGxlcihcXG4gICAgbW9ja0FkYXB0ZXIuaGFuZGxlcnMsXFxuICAgIGNvbmZpZy5tZXRob2QsXFxuICAgIHVybCxcXG4gICAgY29uZmlnLmRhdGEsXFxuICAgIGNvbmZpZy5wYXJhbXMsXFxuICAgIChjb25maWcuaGVhZGVycyAmJiBjb25maWcuaGVhZGVycy5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXhpb3NIZWFkZXJzJylcXG4gICAgICA/IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZy5oZWFkZXJzKVxcbiAgICAgIDogY29uZmlnLmhlYWRlcnMsXFxuICAgIGNvbmZpZy5iYXNlVVJMXFxuICApO1xcblxcbiAgaWYgKGhhbmRsZXIpIHtcXG4gICAgaWYgKGhhbmRsZXIubGVuZ3RoID09PSA3KSB7XFxuICAgICAgdXRpbHMucHVyZ2VJZlJlcGx5T25jZShtb2NrQWRhcHRlciwgaGFuZGxlcik7XFxuICAgIH1cXG5cXG4gICAgaWYgKGhhbmRsZXIubGVuZ3RoID09PSAyKSB7XFxuICAgICAgLy8gcGFzc1Rocm91Z2ggaGFuZGxlclxcbiAgICAgIHBhc3NUaHJvdWdoUmVxdWVzdChtb2NrQWRhcHRlciwgcmVzb2x2ZSwgcmVqZWN0LCBjb25maWcpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoYW5kbGVyWzNdICE9PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgdXRpbHMuc2V0dGxlKFxcbiAgICAgICAgcmVzb2x2ZSxcXG4gICAgICAgIHJlamVjdCxcXG4gICAgICAgIG1ha2VSZXNwb25zZShoYW5kbGVyLnNsaWNlKDMpLCBjb25maWcpLFxcbiAgICAgICAgbW9ja0FkYXB0ZXIuZGVsYXlSZXNwb25zZVxcbiAgICAgICk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXJbM10oY29uZmlnKTtcXG4gICAgICAvLyBUT0RPIHRocm93IGEgc2FuZSBleGNlcHRpb24gd2hlbiByZXR1cm4gdmFsdWUgaXMgaW5jb3JyZWN0XFxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQudGhlbiAhPT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgdXRpbHMuc2V0dGxlKFxcbiAgICAgICAgICByZXNvbHZlLFxcbiAgICAgICAgICByZWplY3QsXFxuICAgICAgICAgIG1ha2VSZXNwb25zZShyZXN1bHQsIGNvbmZpZyksXFxuICAgICAgICAgIG1vY2tBZGFwdGVyLmRlbGF5UmVzcG9uc2VcXG4gICAgICAgICk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJlc3VsdC50aGVuKFxcbiAgICAgICAgICBmdW5jdGlvbiAocmVzdWx0KSB7XFxuICAgICAgICAgICAgaWYgKHJlc3VsdC5jb25maWcgJiYgcmVzdWx0LnN0YXR1cykge1xcbiAgICAgICAgICAgICAgdXRpbHMuc2V0dGxlKFxcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxcbiAgICAgICAgICAgICAgICByZWplY3QsXFxuICAgICAgICAgICAgICAgIG1ha2VSZXNwb25zZShcXG4gICAgICAgICAgICAgICAgICBbcmVzdWx0LnN0YXR1cywgcmVzdWx0LmRhdGEsIHJlc3VsdC5oZWFkZXJzXSxcXG4gICAgICAgICAgICAgICAgICByZXN1bHQuY29uZmlnXFxuICAgICAgICAgICAgICAgICksXFxuICAgICAgICAgICAgICAgIDBcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHV0aWxzLnNldHRsZShcXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSxcXG4gICAgICAgICAgICAgICAgcmVqZWN0LFxcbiAgICAgICAgICAgICAgICBtYWtlUmVzcG9uc2UocmVzdWx0LCBjb25maWcpLFxcbiAgICAgICAgICAgICAgICBtb2NrQWRhcHRlci5kZWxheVJlc3BvbnNlXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XFxuICAgICAgICAgICAgaWYgKG1vY2tBZGFwdGVyLmRlbGF5UmVzcG9uc2UgPiAwKSB7XFxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcXG4gICAgICAgICAgICAgIH0sIG1vY2tBZGFwdGVyLmRlbGF5UmVzcG9uc2UpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIC8vIGhhbmRsZXIgbm90IGZvdW5kXFxuICAgIHN3aXRjaCAobW9ja0FkYXB0ZXIub25Ob01hdGNoKSB7XFxuICAgICAgY2FzZSBcXFwicGFzc3Rocm91Z2hcXFwiOlxcbiAgICAgICAgcGFzc1Rocm91Z2hSZXF1ZXN0KG1vY2tBZGFwdGVyLCByZXNvbHZlLCByZWplY3QsIGNvbmZpZyk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFxcXCJ0aHJvd0V4Y2VwdGlvblxcXCI6XFxuICAgICAgICB0aHJvdyB1dGlscy5jcmVhdGVDb3VsZE5vdEZpbmRNb2NrRXJyb3IoY29uZmlnKTtcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgdXRpbHMuc2V0dGxlKFxcbiAgICAgICAgICByZXNvbHZlLFxcbiAgICAgICAgICByZWplY3QsXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBzdGF0dXM6IDQwNCxcXG4gICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgbW9ja0FkYXB0ZXIuZGVsYXlSZXNwb25zZVxcbiAgICAgICAgKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZVJlcXVlc3Q7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQXhpb3NNb2NrQWRhcHRlci8uL3NyYy9oYW5kbGVfcmVxdWVzdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgaGFuZGxlUmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGFuZGxlX3JlcXVlc3QgKi8gXFxcIi4vc3JjL2hhbmRsZV9yZXF1ZXN0LmpzXFxcIik7XFxudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscyAqLyBcXFwiLi9zcmMvdXRpbHMuanNcXFwiKTtcXG5cXG52YXIgVkVSQlMgPSBbXFxuICBcXFwiZ2V0XFxcIixcXG4gIFxcXCJwb3N0XFxcIixcXG4gIFxcXCJoZWFkXFxcIixcXG4gIFxcXCJkZWxldGVcXFwiLFxcbiAgXFxcInBhdGNoXFxcIixcXG4gIFxcXCJwdXRcXFwiLFxcbiAgXFxcIm9wdGlvbnNcXFwiLFxcbiAgXFxcImxpc3RcXFwiLFxcbiAgXFxcImxpbmtcXFwiLFxcbiAgXFxcInVubGlua1xcXCIsXFxuXTtcXG5cXG5mdW5jdGlvbiBhZGFwdGVyKCkge1xcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWcpIHtcXG4gICAgdmFyIG1vY2tBZGFwdGVyID0gdGhpcztcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICBoYW5kbGVSZXF1ZXN0KG1vY2tBZGFwdGVyLCByZXNvbHZlLCByZWplY3QsIGNvbmZpZyk7XFxuICAgIH0pO1xcbiAgfS5iaW5kKHRoaXMpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRWZXJiT2JqZWN0KCkge1xcbiAgcmV0dXJuIFZFUkJTLnJlZHVjZShmdW5jdGlvbiAoYWNjdW11bGF0b3IsIHZlcmIpIHtcXG4gICAgYWNjdW11bGF0b3JbdmVyYl0gPSBbXTtcXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xcbiAgfSwge30pO1xcbn1cXG5cXG5mdW5jdGlvbiByZXNldCgpIHtcXG4gIHJlc2V0SGFuZGxlcnMuY2FsbCh0aGlzKTtcXG4gIHJlc2V0SGlzdG9yeS5jYWxsKHRoaXMpO1xcbn1cXG5cXG5mdW5jdGlvbiByZXNldEhhbmRsZXJzKCkge1xcbiAgdGhpcy5oYW5kbGVycyA9IGdldFZlcmJPYmplY3QoKTtcXG59XFxuXFxuZnVuY3Rpb24gcmVzZXRIaXN0b3J5KCkge1xcbiAgdGhpcy5oaXN0b3J5ID0gZ2V0VmVyYk9iamVjdCgpO1xcbn1cXG5cXG5mdW5jdGlvbiBNb2NrQWRhcHRlcihheGlvc0luc3RhbmNlLCBvcHRpb25zKSB7XFxuICByZXNldC5jYWxsKHRoaXMpO1xcblxcbiAgaWYgKGF4aW9zSW5zdGFuY2UpIHtcXG4gICAgdGhpcy5heGlvc0luc3RhbmNlID0gYXhpb3NJbnN0YW5jZTtcXG4gICAgLy8gQ2xvbmUgdGhlIGF4aW9zIGluc3RhbmNlIHRvIHJlbW92ZSBpbnRlcmNlcHRvcnNcXG4gICAgLy8gdGhpcyBpcyB1c2VkIGZvciB0aGUgcGFzc1Rocm91Z2ggbW9kZSB3aXRoIGF4aW9zID4gMS4yXFxuICAgIHRoaXMuYXhpb3NJbnN0YW5jZVdpdGhvdXRJbnRlcmNlcHRvcnMgPSBheGlvc0luc3RhbmNlLmNyZWF0ZVxcbiAgICAgID8gYXhpb3NJbnN0YW5jZS5jcmVhdGUoKVxcbiAgICAgIDogdW5kZWZpbmVkO1xcblxcbiAgICB0aGlzLm9yaWdpbmFsQWRhcHRlciA9IGF4aW9zSW5zdGFuY2UuZGVmYXVsdHMuYWRhcHRlcjtcXG4gICAgdGhpcy5kZWxheVJlc3BvbnNlID1cXG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMuZGVsYXlSZXNwb25zZSA+IDAgPyBvcHRpb25zLmRlbGF5UmVzcG9uc2UgOiBudWxsO1xcbiAgICB0aGlzLm9uTm9NYXRjaCA9IChvcHRpb25zICYmIG9wdGlvbnMub25Ob01hdGNoKSB8fCBudWxsO1xcbiAgICBheGlvc0luc3RhbmNlLmRlZmF1bHRzLmFkYXB0ZXIgPSB0aGlzLmFkYXB0ZXIuY2FsbCh0aGlzKTtcXG4gIH0gZWxzZSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXFwiUGxlYXNlIHByb3ZpZGUgYW4gaW5zdGFuY2Ugb2YgYXhpb3MgdG8gbW9ja1xcXCIpO1xcbiAgfVxcbn1cXG5cXG5Nb2NrQWRhcHRlci5wcm90b3R5cGUuYWRhcHRlciA9IGFkYXB0ZXI7XFxuXFxuTW9ja0FkYXB0ZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKCkge1xcbiAgaWYgKHRoaXMuYXhpb3NJbnN0YW5jZSkge1xcbiAgICB0aGlzLmF4aW9zSW5zdGFuY2UuZGVmYXVsdHMuYWRhcHRlciA9IHRoaXMub3JpZ2luYWxBZGFwdGVyO1xcbiAgICB0aGlzLmF4aW9zSW5zdGFuY2UgPSB1bmRlZmluZWQ7XFxuICB9XFxufTtcXG5cXG5Nb2NrQWRhcHRlci5wcm90b3R5cGUucmVzZXQgPSByZXNldDtcXG5Nb2NrQWRhcHRlci5wcm90b3R5cGUucmVzZXRIYW5kbGVycyA9IHJlc2V0SGFuZGxlcnM7XFxuTW9ja0FkYXB0ZXIucHJvdG90eXBlLnJlc2V0SGlzdG9yeSA9IHJlc2V0SGlzdG9yeTtcXG5cXG5WRVJCUy5jb25jYXQoXFxcImFueVxcXCIpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xcbiAgdmFyIG1ldGhvZE5hbWUgPSBcXFwib25cXFwiICsgbWV0aG9kLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbWV0aG9kLnNsaWNlKDEpO1xcbiAgTW9ja0FkYXB0ZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKG1hdGNoZXIsIGJvZHksIHJlcXVlc3RIZWFkZXJzKSB7XFxuICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgIHZhciBtYXRjaGVyID0gbWF0Y2hlciA9PT0gdW5kZWZpbmVkID8gLy4qLyA6IG1hdGNoZXI7XFxuXFxuICAgIGZ1bmN0aW9uIHJlcGx5KGNvZGUsIHJlc3BvbnNlLCBoZWFkZXJzKSB7XFxuICAgICAgdmFyIGhhbmRsZXIgPSBbbWF0Y2hlciwgYm9keSwgcmVxdWVzdEhlYWRlcnMsIGNvZGUsIHJlc3BvbnNlLCBoZWFkZXJzXTtcXG4gICAgICBhZGRIYW5kbGVyKG1ldGhvZCwgX3RoaXMuaGFuZGxlcnMsIGhhbmRsZXIpO1xcbiAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiByZXBseU9uY2UoY29kZSwgcmVzcG9uc2UsIGhlYWRlcnMpIHtcXG4gICAgICB2YXIgaGFuZGxlciA9IFtcXG4gICAgICAgIG1hdGNoZXIsXFxuICAgICAgICBib2R5LFxcbiAgICAgICAgcmVxdWVzdEhlYWRlcnMsXFxuICAgICAgICBjb2RlLFxcbiAgICAgICAgcmVzcG9uc2UsXFxuICAgICAgICBoZWFkZXJzLFxcbiAgICAgICAgdHJ1ZSxcXG4gICAgICBdO1xcbiAgICAgIGFkZEhhbmRsZXIobWV0aG9kLCBfdGhpcy5oYW5kbGVycywgaGFuZGxlcik7XFxuICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgcmVwbHk6IHJlcGx5LFxcblxcbiAgICAgIHJlcGx5T25jZTogcmVwbHlPbmNlLFxcblxcbiAgICAgIHBhc3NUaHJvdWdoOiBmdW5jdGlvbiBwYXNzVGhyb3VnaCgpIHtcXG4gICAgICAgIHZhciBoYW5kbGVyID0gW21hdGNoZXIsIGJvZHldO1xcbiAgICAgICAgYWRkSGFuZGxlcihtZXRob2QsIF90aGlzLmhhbmRsZXJzLCBoYW5kbGVyKTtcXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgICB9LFxcblxcbiAgICAgIGFib3J0UmVxdWVzdDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHJlcGx5KGZ1bmN0aW9uIChjb25maWcpIHtcXG4gICAgICAgICAgdmFyIGVycm9yID0gdXRpbHMuY3JlYXRlQXhpb3NFcnJvcihcXG4gICAgICAgICAgICBcXFwiUmVxdWVzdCBhYm9ydGVkXFxcIixcXG4gICAgICAgICAgICBjb25maWcsXFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxcbiAgICAgICAgICAgIFxcXCJFQ09OTkFCT1JURURcXFwiXFxuICAgICAgICAgICk7XFxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XFxuICAgICAgICB9KTtcXG4gICAgICB9LFxcblxcbiAgICAgIGFib3J0UmVxdWVzdE9uY2U6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiByZXBseU9uY2UoZnVuY3Rpb24gKGNvbmZpZykge1xcbiAgICAgICAgICB2YXIgZXJyb3IgPSB1dGlscy5jcmVhdGVBeGlvc0Vycm9yKFxcbiAgICAgICAgICAgIFxcXCJSZXF1ZXN0IGFib3J0ZWRcXFwiLFxcbiAgICAgICAgICAgIGNvbmZpZyxcXG4gICAgICAgICAgICB1bmRlZmluZWQsXFxuICAgICAgICAgICAgXFxcIkVDT05OQUJPUlRFRFxcXCJcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sXFxuXFxuICAgICAgbmV0d29ya0Vycm9yOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gcmVwbHkoZnVuY3Rpb24gKGNvbmZpZykge1xcbiAgICAgICAgICB2YXIgZXJyb3IgPSB1dGlscy5jcmVhdGVBeGlvc0Vycm9yKFxcXCJOZXR3b3JrIEVycm9yXFxcIiwgY29uZmlnKTtcXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sXFxuXFxuICAgICAgbmV0d29ya0Vycm9yT25jZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHJlcGx5T25jZShmdW5jdGlvbiAoY29uZmlnKSB7XFxuICAgICAgICAgIHZhciBlcnJvciA9IHV0aWxzLmNyZWF0ZUF4aW9zRXJyb3IoXFxcIk5ldHdvcmsgRXJyb3JcXFwiLCBjb25maWcpO1xcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSxcXG5cXG4gICAgICB0aW1lb3V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gcmVwbHkoZnVuY3Rpb24gKGNvbmZpZykge1xcbiAgICAgICAgICB2YXIgZXJyb3IgPSB1dGlscy5jcmVhdGVBeGlvc0Vycm9yKFxcbiAgICAgICAgICAgIGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlIHx8XFxuICAgICAgICAgICAgICBcXFwidGltZW91dCBvZiBcXFwiICsgY29uZmlnLnRpbWVvdXQgKyBcXFwibXMgZXhjZWVkZWRcXFwiLFxcbiAgICAgICAgICAgIGNvbmZpZyxcXG4gICAgICAgICAgICB1bmRlZmluZWQsXFxuICAgICAgICAgICAgXFxcIkVDT05OQUJPUlRFRFxcXCJcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sXFxuXFxuICAgICAgdGltZW91dE9uY2U6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiByZXBseU9uY2UoZnVuY3Rpb24gKGNvbmZpZykge1xcbiAgICAgICAgICB2YXIgZXJyb3IgPSB1dGlscy5jcmVhdGVBeGlvc0Vycm9yKFxcbiAgICAgICAgICAgIGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlIHx8XFxuICAgICAgICAgICAgICBcXFwidGltZW91dCBvZiBcXFwiICsgY29uZmlnLnRpbWVvdXQgKyBcXFwibXMgZXhjZWVkZWRcXFwiLFxcbiAgICAgICAgICAgIGNvbmZpZyxcXG4gICAgICAgICAgICB1bmRlZmluZWQsXFxuICAgICAgICAgICAgXFxcIkVDT05OQUJPUlRFRFxcXCJcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sXFxuICAgIH07XFxuICB9O1xcbn0pO1xcblxcbmZ1bmN0aW9uIGZpbmRJbkhhbmRsZXJzKG1ldGhvZCwgaGFuZGxlcnMsIGhhbmRsZXIpIHtcXG4gIHZhciBpbmRleCA9IC0xO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyc1ttZXRob2RdLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHZhciBpdGVtID0gaGFuZGxlcnNbbWV0aG9kXVtpXTtcXG4gICAgdmFyIGlzUmVwbHlPbmNlID0gaXRlbS5sZW5ndGggPT09IDc7XFxuICAgIHZhciBjb21wYXJlUGF0aHMgPVxcbiAgICAgIGl0ZW1bMF0gaW5zdGFuY2VvZiBSZWdFeHAgJiYgaGFuZGxlclswXSBpbnN0YW5jZW9mIFJlZ0V4cFxcbiAgICAgICAgPyBTdHJpbmcoaXRlbVswXSkgPT09IFN0cmluZyhoYW5kbGVyWzBdKVxcbiAgICAgICAgOiBpdGVtWzBdID09PSBoYW5kbGVyWzBdO1xcbiAgICB2YXIgaXNTYW1lID1cXG4gICAgICBjb21wYXJlUGF0aHMgJiZcXG4gICAgICB1dGlscy5pc0VxdWFsKGl0ZW1bMV0sIGhhbmRsZXJbMV0pICYmXFxuICAgICAgdXRpbHMuaXNFcXVhbChpdGVtWzJdLCBoYW5kbGVyWzJdKTtcXG4gICAgaWYgKGlzU2FtZSAmJiAhaXNSZXBseU9uY2UpIHtcXG4gICAgICBpbmRleCA9IGk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBpbmRleDtcXG59XFxuXFxuZnVuY3Rpb24gYWRkSGFuZGxlcihtZXRob2QsIGhhbmRsZXJzLCBoYW5kbGVyKSB7XFxuICBpZiAobWV0aG9kID09PSBcXFwiYW55XFxcIikge1xcbiAgICBWRVJCUy5mb3JFYWNoKGZ1bmN0aW9uICh2ZXJiKSB7XFxuICAgICAgaGFuZGxlcnNbdmVyYl0ucHVzaChoYW5kbGVyKTtcXG4gICAgfSk7XFxuICB9IGVsc2Uge1xcbiAgICB2YXIgaW5kZXhPZkV4aXN0aW5nSGFuZGxlciA9IGZpbmRJbkhhbmRsZXJzKG1ldGhvZCwgaGFuZGxlcnMsIGhhbmRsZXIpO1xcbiAgICBpZiAoaW5kZXhPZkV4aXN0aW5nSGFuZGxlciA+IC0xICYmIGhhbmRsZXIubGVuZ3RoIDwgNykge1xcbiAgICAgIGhhbmRsZXJzW21ldGhvZF0uc3BsaWNlKGluZGV4T2ZFeGlzdGluZ0hhbmRsZXIsIDEsIGhhbmRsZXIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGhhbmRsZXJzW21ldGhvZF0ucHVzaChoYW5kbGVyKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tBZGFwdGVyO1xcbm1vZHVsZS5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBNb2NrQWRhcHRlcjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9BeGlvc01vY2tBZGFwdGVyLy4vc3JjL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaXNfYmxvYi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2lzX2Jsb2IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKiFcXG4gKiBNSVQgTGljZW5zZVxcbiAqXFxuICogQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoaHR0cHM6Ly9zaW5kcmVzb3JodXMuY29tKVxcbiAqXFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXFxuICogZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxcbiAqIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4gKiBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuICpcXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZVxcbiAqIFNvZnR3YXJlLlxcbiAqXFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEVcXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1JcXG4gKiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuICogT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcbiAqL1xcblxcbmZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xcbiAgaWYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBCbG9iIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEJsb2JdJztcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBpc0Jsb2I7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQXhpb3NNb2NrQWRhcHRlci8uL3NyYy9pc19ibG9iLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciBheGlvcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGF4aW9zICovIFxcXCJheGlvc1xcXCIpO1xcbnZhciBpc0VxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZmFzdC1kZWVwLWVxdWFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanNcXFwiKTtcXG52YXIgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpcy1idWZmZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1xcXCIpO1xcbnZhciBpc0Jsb2IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzX2Jsb2IgKi8gXFxcIi4vc3JjL2lzX2Jsb2IuanNcXFwiKTtcXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbmZ1bmN0aW9uIGZpbmQoYXJyYXksIHByZWRpY2F0ZSkge1xcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XFxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSBcXFwiW29iamVjdCBGdW5jdGlvbl1cXFwiO1xcbn1cXG5cXG5mdW5jdGlvbiBpc09iamVjdE9yQXJyYXkodmFsKSB7XFxuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFxcXCJvYmplY3RcXFwiO1xcbn1cXG5cXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcXG4gIHJldHVybiBpc09iamVjdE9yQXJyYXkodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcXG59XFxuXFxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09IFxcXCJbb2JqZWN0IEFycmF5QnVmZmVyXVxcXCI7XFxufVxcblxcbmZ1bmN0aW9uIGNvbWJpbmVVcmxzKGJhc2VVUkwsIHVybCkge1xcbiAgaWYgKGJhc2VVUkwpIHtcXG4gICAgcmV0dXJuIGJhc2VVUkwucmVwbGFjZSgvXFxcXC8rJC8sIFxcXCJcXFwiKSArIFxcXCIvXFxcIiArIHVybC5yZXBsYWNlKC9eXFxcXC8rLywgXFxcIlxcXCIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHVybDtcXG59XFxuXFxuZnVuY3Rpb24gZmluZEhhbmRsZXIoXFxuICBoYW5kbGVycyxcXG4gIG1ldGhvZCxcXG4gIHVybCxcXG4gIGJvZHksXFxuICBwYXJhbWV0ZXJzLFxcbiAgaGVhZGVycyxcXG4gIGJhc2VVUkxcXG4pIHtcXG4gIHJldHVybiBmaW5kKGhhbmRsZXJzW21ldGhvZC50b0xvd2VyQ2FzZSgpXSwgZnVuY3Rpb24gKGhhbmRsZXIpIHtcXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyWzBdID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgIHJldHVybiAoXFxuICAgICAgICAoaXNVcmxNYXRjaGluZyh1cmwsIGhhbmRsZXJbMF0pIHx8XFxuICAgICAgICAgIGlzVXJsTWF0Y2hpbmcoY29tYmluZVVybHMoYmFzZVVSTCwgdXJsKSwgaGFuZGxlclswXSkpICYmXFxuICAgICAgICBpc0JvZHlPclBhcmFtZXRlcnNNYXRjaGluZyhtZXRob2QsIGJvZHksIHBhcmFtZXRlcnMsIGhhbmRsZXJbMV0pICYmXFxuICAgICAgICBpc09iamVjdE1hdGNoaW5nKGhlYWRlcnMsIGhhbmRsZXJbMl0pXFxuICAgICAgKTtcXG4gICAgfSBlbHNlIGlmIChoYW5kbGVyWzBdIGluc3RhbmNlb2YgUmVnRXhwKSB7XFxuICAgICAgcmV0dXJuIChcXG4gICAgICAgIChoYW5kbGVyWzBdLnRlc3QodXJsKSB8fCBoYW5kbGVyWzBdLnRlc3QoY29tYmluZVVybHMoYmFzZVVSTCwgdXJsKSkpICYmXFxuICAgICAgICBpc0JvZHlPclBhcmFtZXRlcnNNYXRjaGluZyhtZXRob2QsIGJvZHksIHBhcmFtZXRlcnMsIGhhbmRsZXJbMV0pICYmXFxuICAgICAgICBpc09iamVjdE1hdGNoaW5nKGhlYWRlcnMsIGhhbmRsZXJbMl0pXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGlzVXJsTWF0Y2hpbmcodXJsLCByZXF1aXJlZCkge1xcbiAgdmFyIG5vU2xhc2hVcmwgPSB1cmxbMF0gPT09IFxcXCIvXFxcIiA/IHVybC5zdWJzdHIoMSkgOiB1cmw7XFxuICB2YXIgbm9TbGFzaFJlcXVpcmVkID0gcmVxdWlyZWRbMF0gPT09IFxcXCIvXFxcIiA/IHJlcXVpcmVkLnN1YnN0cigxKSA6IHJlcXVpcmVkO1xcbiAgcmV0dXJuIG5vU2xhc2hVcmwgPT09IG5vU2xhc2hSZXF1aXJlZDtcXG59XFxuXFxuZnVuY3Rpb24gaXNCb2R5T3JQYXJhbWV0ZXJzTWF0Y2hpbmcobWV0aG9kLCBib2R5LCBwYXJhbWV0ZXJzLCByZXF1aXJlZCkge1xcbiAgdmFyIGFsbG93ZWRQYXJhbXNNZXRob2RzID0gW1xcXCJkZWxldGVcXFwiLCBcXFwiZ2V0XFxcIiwgXFxcImhlYWRcXFwiLCBcXFwib3B0aW9uc1xcXCJdO1xcbiAgaWYgKGFsbG93ZWRQYXJhbXNNZXRob2RzLmluZGV4T2YobWV0aG9kLnRvTG93ZXJDYXNlKCkpID49IDApIHtcXG4gICAgdmFyIGRhdGEgPSByZXF1aXJlZCA/IHJlcXVpcmVkLmRhdGEgOiB1bmRlZmluZWQ7XFxuICAgIHZhciBwYXJhbXMgPSByZXF1aXJlZCA/IHJlcXVpcmVkLnBhcmFtcyA6IHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuIGlzT2JqZWN0TWF0Y2hpbmcocGFyYW1ldGVycywgcGFyYW1zKSAmJiBpc0JvZHlNYXRjaGluZyhib2R5LCBkYXRhKTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBpc0JvZHlNYXRjaGluZyhib2R5LCByZXF1aXJlZCk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGlzT2JqZWN0TWF0Y2hpbmcoYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgaWYgKGV4cGVjdGVkID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xcbiAgaWYgKHR5cGVvZiBleHBlY3RlZC5hc3ltbWV0cmljTWF0Y2ggPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgcmV0dXJuIGV4cGVjdGVkLmFzeW1tZXRyaWNNYXRjaChhY3R1YWwpO1xcbiAgfVxcbiAgcmV0dXJuIGlzRXF1YWwoYWN0dWFsLCBleHBlY3RlZCk7XFxufVxcblxcbmZ1bmN0aW9uIGlzQm9keU1hdGNoaW5nKGJvZHksIHJlcXVpcmVkQm9keSkge1xcbiAgaWYgKHJlcXVpcmVkQm9keSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbiAgdmFyIHBhcnNlZEJvZHk7XFxuICB0cnkge1xcbiAgICBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcXG4gIH0gY2F0Y2ggKGUpIHt9XFxuXFxuICByZXR1cm4gaXNPYmplY3RNYXRjaGluZyhwYXJzZWRCb2R5ID8gcGFyc2VkQm9keSA6IGJvZHksIHJlcXVpcmVkQm9keSk7XFxufVxcblxcbmZ1bmN0aW9uIHB1cmdlSWZSZXBseU9uY2UobW9jaywgaGFuZGxlcikge1xcbiAgT2JqZWN0LmtleXMobW9jay5oYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHZhciBpbmRleCA9IG1vY2suaGFuZGxlcnNba2V5XS5pbmRleE9mKGhhbmRsZXIpO1xcbiAgICBpZiAoaW5kZXggPiAtMSkge1xcbiAgICAgIG1vY2suaGFuZGxlcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICB9XFxuICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UsIGRlbGF5KSB7XFxuICBpZiAoZGVsYXkgPiAwKSB7XFxuICAgIHNldFRpbWVvdXQoc2V0dGxlLCBkZWxheSwgcmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmIChcXG4gICAgIXJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cyB8fFxcbiAgICByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKVxcbiAgKSB7XFxuICAgIHJlc29sdmUocmVzcG9uc2UpO1xcbiAgfSBlbHNlIHtcXG4gICAgcmVqZWN0KFxcbiAgICAgIGNyZWF0ZUF4aW9zRXJyb3IoXFxuICAgICAgICBcXFwiUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSBcXFwiICsgcmVzcG9uc2Uuc3RhdHVzLFxcbiAgICAgICAgcmVzcG9uc2UuY29uZmlnLFxcbiAgICAgICAgcmVzcG9uc2VcXG4gICAgICApXFxuICAgICk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUF4aW9zRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXNwb25zZSwgY29kZSkge1xcbiAgLy8gYXhpb3MgdjAuMjcuMCsgZGVmaW5lcyBBeGlvc0Vycm9yIGFzIGNvbnN0cnVjdG9yXFxuICBpZiAodHlwZW9mIGF4aW9zLkF4aW9zRXJyb3IgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgcmV0dXJuIGF4aW9zLkF4aW9zRXJyb3IuZnJvbShuZXcgRXJyb3IobWVzc2FnZSksIGNvZGUsIGNvbmZpZywgbnVsbCwgcmVzcG9uc2UpO1xcbiAgfVxcblxcbiAgLy8gaGFuZGxpbmcgZm9yIGF4aW9zIHYwLjI2LjEgYW5kIGJlbG93XFxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XFxuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xcbiAgaWYgKHJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcXG4gIH1cXG4gIGlmIChjb2RlICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XFxuICB9XFxuXFxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgLy8gU3RhbmRhcmRcXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxcbiAgICAgIC8vIE1pY3Jvc29mdFxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXFxuICAgICAgLy8gTW96aWxsYVxcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxcbiAgICAgIC8vIEF4aW9zXFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXFxuICAgIH07XFxuICB9O1xcbiAgcmV0dXJuIGVycm9yO1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVDb3VsZE5vdEZpbmRNb2NrRXJyb3IoY29uZmlnKSB7XFxuICB2YXIgbWVzc2FnZSA9XFxuICAgIFxcXCJDb3VsZCBub3QgZmluZCBtb2NrIGZvcjogXFxcXG5cXFwiICtcXG4gICAgSlNPTi5zdHJpbmdpZnkoY29uZmlnLCBbXFxcIm1ldGhvZFxcXCIsIFxcXCJ1cmxcXFwiXSwgMik7XFxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XFxuICBlcnJvci5pc0NvdWxkTm90RmluZE1vY2tFcnJvciA9IHRydWU7XFxuICBlcnJvci51cmwgPSBjb25maWcudXJsO1xcbiAgZXJyb3IubWV0aG9kID0gY29uZmlnLm1ldGhvZDtcXG4gIHJldHVybiBlcnJvcjtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBmaW5kOiBmaW5kLFxcbiAgZmluZEhhbmRsZXI6IGZpbmRIYW5kbGVyLFxcbiAgcHVyZ2VJZlJlcGx5T25jZTogcHVyZ2VJZlJlcGx5T25jZSxcXG4gIHNldHRsZTogc2V0dGxlLFxcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXFxuICBpc09iamVjdE9yQXJyYXk6IGlzT2JqZWN0T3JBcnJheSxcXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcXG4gIGlzQmxvYjogaXNCbG9iLFxcbiAgaXNCb2R5T3JQYXJhbWV0ZXJzTWF0Y2hpbmc6IGlzQm9keU9yUGFyYW1ldGVyc01hdGNoaW5nLFxcbiAgaXNFcXVhbDogaXNFcXVhbCxcXG4gIGNyZWF0ZUF4aW9zRXJyb3I6IGNyZWF0ZUF4aW9zRXJyb3IsXFxuICBjcmVhdGVDb3VsZE5vdEZpbmRNb2NrRXJyb3I6IGNyZWF0ZUNvdWxkTm90RmluZE1vY2tFcnJvcixcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0F4aW9zTW9ja0FkYXB0ZXIvLi9zcmMvdXRpbHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJheGlvc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIFwiYXhpb3NcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfYXhpb3NfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LmpzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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