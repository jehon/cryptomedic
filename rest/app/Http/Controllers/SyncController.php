<?php namespace App\Http\Controllers;

use App\Patient;
use App\SyncComputer;
use App\Http\Controllers\Controller;
use DB;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Input;
use Illuminate\Support\Facades\Request;

require_once(__DIR__ . "/../../../../php/references.php");
use \References;

// TODO: If the computer key is forgotten, then reset the client... 
define("sync_packet_size", 200);

class SyncController extends Controller {
	// @see http://laravel.com/docs/5.0/controllers
	
	public function _getUnionSQL($ts, $id) {
		$this->sqlParamsUnion = [];
		$sql = "";
		
		foreach((References::$model2db + [ "Deleted" => "deleteds" ]) as $m => $t) {
			if ($sql) {
				$sql .= " UNION \n";
			}
			$patient_id = ($t == "patients" ? "id" : "patient_id");
			$sql .= "("
					. "SELECT greatest(created_at, updated_at) as ts, '$t' as t, $patient_id as patient_id"
					. " FROM $t "
					. " WHERE (greatest(created_at, updated_at) > :ts0_{$m}) "
					. "   OR ((greatest(created_at, updated_at) = :ts1_{$m}) AND ($patient_id > :id1_${m}))"
					. " ORDER BY greatest(created_at, updated_at), $patient_id)";
			$this->sqlParamsUnion["ts0_{$m}"]    = $this->sqlParamsUnion["ts1_${m}"]    = $ts;
			$this->sqlParamsUnion["id1_{$m}"]    = $id;
		}
		return $sql;
	}
	
	public function _getCount($ts, $id) {
		$sqlu = $this->_getUnionSQL($ts, $id);
		$res = DB::select("SELECT count(*) as c FROM ($sqlu) as p", $this->sqlParamsUnion);
		return $res[0]->c;
	}
	
	public function _getList($ts, $id) {
		$sqlu = $this->_getUnionSQL($ts, $id);
		$res = DB::select("SELECT MAX(ts) as ts, patient_id, MAX(t) as t \nFROM (\n$sqlu\n) as p GROUP BY patient_id "
			. "ORDER BY MAX(ts), patient_id "
			. "LIMIT " . constant("sync_packet_size"), 
			$this->sqlParamsUnion);
		$data = [];
		
		foreach($res as $i => $r) {
			$pat = FolderController::getFolder($r->patient_id);
			if ($pat) {
				$data[$i]['record'] = $pat;
			} else {
				$data[$i] = [ 'id' => $r->patient_id, '_deleted' => true ];
			}
			$data[$i]['_dueTo'] = $r->t . "#" . $r->patient_id;
			$data[$i]['checkpoint'] = $r->ts . "|" . $r->patient_id;
		}
		
		return $data;
	}

	public function _syncData($old_cp) {
		$offline = [];
			
		// cp: timestamp|patient_id (generated by $last in _offline->checkpoint)
		if ($old_cp == "") {
			$cp = array("", -1);	
			$offline['reset'] = 1;
		} else {
			$cp = explode("|", $old_cp);
			if (count($cp) != 2) {
				$cp = array("", -1);
				$offline['reset'] = 1;
			} else {
				$offline['reset'] = 0;
			}
		}

		$offline['data'] = $this->_getList($cp[0], $cp[1]);
		// TODO: remaining should be calculated based on the new CP
		$offline['remaining'] = $this->_getCount($cp[0], $cp[1]) - count($offline['data']);
		
		if (count($offline['data']) > 0) {
			$offline["checkpoint"] = end($offline['data'])['checkpoint'];
			$offline["isfinal"] = (count($offline['data']) < constant("sync_packet_size"));
		} else {
			$offline["checkpoint"] = $old_cp;
			$offline["isfinal"] = true;
		}

		// Store the information for helping understanding what is happening out there...
		$computerId = session()->get('computerId');
		$computer = SyncComputer::firstOrCreate([ "computer_id" => $computerId ]);
		$computer->last_sync = $old_cp;
		$computer->last_sync_final = ($offline['remaining'] == 0);
		$computer->save();
		
		return $offline;
	}

	public function sync() {
		$old_cp = Request::input("cp", false);
		if ($old_cp === false) {
			return response();
		}
		$data = array("_offline" => $this->_syncData($old_cp));
	
		return Response($data);
	}
}
