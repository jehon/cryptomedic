<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/fetchfull-elements/src/fetchfull-element.html">

<dom-module name="cryptomedic-data-service">
  <template>
    <fetchfull-element id='network'>
      <content></content>
    </fetchfull-element>
  </template>

  <script>
    /* global Database, background, API_VERSION, userCb, syncRemainingCb */
    /* exported callbacks */
    (function() {

      let syncRemaining = false;
      syncRemainingCb.add((data) => {
        // Store the information locally at least
        syncRemaining = data;
      });

      // Build up the cryptomedicComputerId
      if (!localStorage.cryptomedicComputerId) {
        var mask = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        var result = '';
        for (var i = 0; i < 32; i++) {
          result += mask[Math.floor(Math.random() * mask.length)];
        }
        localStorage.cryptomedicComputerId = result;
      }

      if (!localStorage.syncCheckpoint) {
        localStorage.syncCheckpoint = "";
      }

      let db = new Database();
      let syncedFolders = {};

      let currentlySyncing = false;

      window.cryptomedic = {};
      window.cryptomedic.serverSettings = {};

      Polymer({
        is: 'cryptomedic-data-service',

        properties: {},

        ready: function() {
          // Hook in requestToUrl to add the prefix:
          let r = this.$.network.requestToUrl;
          this.$.network.requestToUrl = function(url) {
            return r.call(this, '/api/' + API_VERSION + '/' + url);
          }
        },

        userCb,
        syncRemainingCb,


        /**************************/
        /*** Start              ***/
        /**************************/

        start: function() {
          return this.$.network
            .reset()
            .requestWithCredentials("include")
            .responseAsJson()
            .onResponseCode(401, () => {
              window.location = "#login";
            })
            .requestWithHeader('X-SYNC-CHECKPOINT', db.getCheckpoint())
            // This is done async % then...
            .onSuccess(json => {
              // Check offline data
              let finished = Promise.resolve();

              // Do we reset the database?
              if (json._offline && json._offline.reset) {
                // Reset the synced info if we are resetting the database
                syncedFolders = {};
                finished = finished.then(() => db.clear());
              }

              // Put ONLINE data
              if (typeof(json.online) != "undefined") {
                finished = finished.then(() => {
                  return db.triageList(json.online, false);
                })
              }

              // Put OFFLINE data (but in background process)
              if (typeof(json._offline) != "undefined") {
                background(() => {
                  db.triageList(json._offline.data, true)
                  .then(() => {
                    // Store the final checkpoint
                    // in case the last line is also present in online, and thus pruned
                    // by the optimization...

                    db.checkpointInDB(json._offline.checkpoint);
                  })
                  .then(() => {
                    // Adapt remaining /Xor/ launch new sync

                    if (json._offline.remaining) {
                      // This is not binded to what I hoped...
                      console.log("Triage: syncRemaining: TODO - syncing again disabled");
                      // TODO: how to continue syncing with or without background???
                      // background(() => { this.doSync() });
                    } else {
                      syncRemaining = false;
                    }
                    syncRemainingCb.fire(json._offline.remaining);
                  });
                });
              }

              // Return final response with original data:
              return finished.then(() => {
                return json;
              });
            });
        },

        /**************************/
        /*** Authentication     ***/
        /**************************/

        doLoginCheck() {
          return this.start()
            .requestWithGet()
            .requestToUrl('auth/settings')
            .requestWithData({
              'computerId': localStorage.cryptomedicComputerId
            })
            .onResponseCode(404, () => {
              return false;
            })
            .then(userCb.fire)
            ;
        },

        doLogin(username, password) {
          return this.start()
            .requestWithPost()
            .requestToUrl('auth/mylogin')
            .requestWithData({
              'username': username,
              'password': password,
              'computerId': localStorage.cryptomedicComputerId
            })
            .then(userCb.fire)
            ;
        },

        /*
         * Simply get the next data
         *
         */
        doSync() {
          // Avoid having two syncing going on in parallel
          if (currentlySyncing) {
            console.info("Already syncing, not doing it again");
          }
          currentlySyncing = true;
          return this.start()
            .requestWithGet()
            .requestToUrl('sync')
            .then((json) => { currentlySyncing = false; return json; })
            ;
        },

        doResync() {
          localStorage.syncCheckpoint = "";
          return this.doSync();
        },

        doLogout(localOnly = false) {
          let finished = Promise.resolve();

          // localOnly could be the "tap" event, we thus check carefully what we receive
          if (localOnly !== true) {
            finished = finished.then(() => {
              return this.start()
                .requestWithGet()
                .requestToUrl('auth/logout');
            });
          }
          finished.then(() => {
            userCb.fire(null);
            syncRemainingCb.fire(false);

          })
          ;
        },

        /**************************/
        /*** Patient            ***/
        /**************************/

        'searchForPatients': function(params) {
          return this.start()
            .requestWithGet()
            .requestWithData(params)
            .requestToUrl('folder')
            .then(function(data) {
              var list = [];
              for(var i in data) {
                list.push(new Patient(data[i]));
              }
              return list;
            })
        },

        'checkReference': function(year, order) {
          return new Promise((resolve, reject) => {
            this.start()
              .requestWithGet()
              .requestToUrl('reference/' + year + '/' + order)
              .onResponseCode(404, () => {
                resolve(false);
              })
              .then(data => {
                resolve(data);
              })
              .catch((error) => {
                reject(error);
                throw error;
              })
          });
        },

        'createReference': function(year, order) {
          return this.start()
            .requestToUrl('reference')
            .requestWithPost()
            .requestWithData({
              'entryyear': year,
              'entryorder': order
            })
        },

        getFolder(type, id) {
          let finished = Promise.resolve();

          if (typeof(syncedFolders[type]) == 'undefined') {
            syncedFolders[type] = {};
          }

          if (typeof(syncedFolders[type][id]) == 'undefined') {
            syncedFolders[type][id] = 0;
          }

          if (syncRemaining) {
            //
            // If we have a cached copy less than 2 hours old, then we use it
            // We make the hypothesis that we are the only one to use it
            // and that no modifications are made otherwise
            //
            if (syncedFolders[type][id] >= (new Date()).getTime() - 2 * 60 * 60 * 1000) {
              console.warn("Trusting last syncs and not going live for ", id);
            } else {
              // We are not finished, let's get the info from the server
              finished = finished.then(() => {
                // Trace the synced patients with a timestamp
                syncedFolders[type][id] = new Date();

                return this.start()
                  .requestWithGet()
                  .requestToUrl(`folder/${type}/${id}`)
                  .then(json => {
                    return json.online;
                  })
              });
            }
          }

          // If no data available, look in the local database
          finished = finished.then(() => {
            return db.getFolder(type, id)
              .then(f => {
                return f;
              })
              ;
          })

          return finished;
        },

        /**************************/
        /*** Patient - File     ***/
        /**************************/

        createFile(data) {
          return this.start()
            .requestWithPost()
            .requestToUrl('fiche/' + data.getModel())
            .requestWithData(nullify(data))
            .then(function(data) {
              return new Folder(data);
            })
            ;
        },

        saveFile(data) {
          return this.start()
            .requestWithPut()
            .requestToUrl('fiche/' + data.getModel() + '/' + data['id'])
            .requestWithData(nullify(data))
            .then(function(data) { return new Folder(data); })
            ;
        },

        deleteFile(data) {
          return this.start()
            .requestWithDelete()
            .requestToUrl('fiche/' + data.getModel() + '/' + data['id'])
            .then(function(data) { return new Folder(data); })
            ;
        },

        unlockFile(data) {
          return this.start()
            .requestWithGet()
            .requestToUrl('unfreeze/' + data.getModel() + '/' + data['id'])
            .then(function(data) { return new Folder(data); })
            ;
        },

        /***********************/
        /*** Report          ***/
        /***********************/

        'getReport': function(reportName, data) {
          return this.start()
            .requestWithGet()
            /* global nullify */
            .requestWithData(nullify(data))
            .requestToUrl('reports/' + reportName)
        },

        /***********************/
        /*** User management ***/
        /***********************/

        'usersList': function() {
          return this.start()
            .requestWithGet()
            .requestToUrl('users')
        },

        'userAdd': function(user) {
          return this.start()
            .requestWithPost()
            .requestToUrl('users')
            .requestWithData(user)
        },

// Check here:
        'userDelete': function(id) {
          return this.start()
            .requestWithDelete()
            .requestToUrl('users/' + id)
        },

// Check here:
        'userUpdate': function(user) {
          return this.start()
            .requestWithPut()
            .requestToUrl('users/' + user.id)
            .requestWithData(user)
        },

// Check here:
        'userPassword': function(id, pwd) {
          return this.start()
            .requestWithPost()
            .requestWithData({ password: pwd })
            .requestToUrl('users/password/' + id)
        }
      });

      return {
        syncRemainingCb,
        userCb
      }
    })();
  </script>
</dom-module>
