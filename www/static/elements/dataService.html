<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module name="cryptomedic-data-service">
  <template>
    <span hidden$=[[!username]]>
      <!-- sync status -->
      <span hidden$="[[remaining]]">
        <img id="sync-ok" src='resources/sync-ok.png'>
        <paper-tooltip>Sync finished, all up-to-date.</paper-tooltip>
      </span>
      <span hidden$="[[!remaining]]">
        <img id="sync-download" src='resources/sync-download.png'>
        <paper-tooltip for='sync-download'>Downloading items</paper-tooltip>
        [[remaining]]
      </span>

      <!-- login status -->
      <span>
        <span id='login_loggedusername'>[[username]]</span>
        <img id='logout' src="resources/logout.gif"/>
        <paper-tooltip for='logout'>Logout [[username]]</paper-tooltip>
      </span>

    </span>
    <!-- <paper-dialog id='modal'> -->
      <!-- <h2>Oups... {{message}}</h2> -->
      <!-- {{details}} -->
    <!-- </paper-dialog> -->
  </template>

  <script>
  /* global DatabaseNew, background */
  (function() {
    // Build up the cryptomedicComputerId
    if (!localStorage.cryptomedicComputerId) {
      var mask = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      var result = '';
      for (var i = 0; i < 32; i++) {
        result += mask[Math.floor(Math.random() * mask.length)];
      }
      localStorage.cryptomedicComputerId = result;
    }

    if (!localStorage.syncCheckpoint) {
      localStorage.syncCheckpoint = "";
    }

    let db = new DatabaseNew();



    //************************************************************************************/
    //**** Generic helper functions
    function sortRecordByTimestamp(a, b) {
      // -1 => a come first
      if (a.checkpoint == b.checkpoint) {
        return 0;
      }
      if (!a.checkpoint) {
        return 1;
      }
      if (!b.checkpoint) {
        return -1;
      }
      if (a.checkpoint < b.checkpoint) {
        return -1
      }
      return 1;
    }

    //************************************************************************************/
    //**** Body builders according to method
    function bodyBuilderGet(options) {
      return Object.keys(options.data).map(function (keyName) {
        return encodeURIComponent(keyName) + '=' + encodeURIComponent(options.data[keyName]);
      }).join('&')
    }

    function bodyBuilderPost(options) {
      var body = new FormData();
      for(var a in options.data) {
        body.append(a, options.data[a]);
      }
      return body;
    }

    function bodyBuilderPut(options) {
      if (!options.headers) {
        options.headers = {};
      }
      // Thanks to: http://blog.gospodarets.com/fetch_in_action/
      options.headers['Content-type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
      return bodyBuilderGet(options);
    }

    //************************************************************************************/
    /*
     * Proxy to new Request(...).fetch
     *
     * Use get() and post() preferably.
     *
     * @var {Function} executeRawRequest
     * @see internals.get
     * @see internals.post
     *
     */
    function executeRawRequest(method, relativeUrl, body, options) {
      options.fullUrl = '/api/v1.1/' + relativeUrl;

      return fetch(new Request(options.fullUrl,
        Object.assign({}, options.fetchOptions,
          {
            method: method,
            credentials: 'include',
            body: body
          }
        )
      ));
    }

    //************************************************************************************/
    // ***** Public API **********
    class OneRequest {
      constructor(options = {}) {
        this.options = Object.assign({},  {
          context: "Undefined",
          errorMsg: null,
          data: false,
          listOfAcceptableHttpStatusCode: [ ],

          onSuccess: (response) => { return response; },
          onError: (error) => { throw error; },
          fetchOptions: {
            headers: new Headers()
          }
        }, options);

        // Append sync status
        this.options.fetchOptions.headers.append("X-SYNC-CHECKPOINT", localStorage.syncCheckpoint);

        this.fired = false;
      }

      setContext(context) {
        this.options.context = context;
        if (!this.options.errorMessage) {
          this.options.errorMessage = context;
        }
        return this;
      }

      setErrorMessage(errorMessage) {
        this.options.errorMessage = errorMessage;
        return this;
      }

      setData(data) {
        this.options.data = data;
        return this;
      }

      setListOfAcceptableHttpStatusCode(list) {
        this.options.listOfAcceptableHttpStatusCode = this.options.listOfAcceptableHttpStatusCode.join(list);
        return this;
      }

      addAcceptableHttpStatusCode(code) {
        this.options.listOfAcceptableHttpStatusCode.push(code);
        return this;
      }

      setOnSuccess(onSuccess) {
        this.options.onSuccess = onSuccess;
        return this;
      }

      setOnError(onError) {
        this.options.onError = onError;
        return this;
      }

      get(relativeUrl) {
        this.request = executeRawRequest('GET', relativeUrl + '?' + bodyBuilderGet(this.options), null, this.options);
        return this.treat();
      }

      post(relativeUrl) {
        this.request =  executeRawRequest('POST', relativeUrl, bodyBuilderPost(this.options), this.options);
        return this.treat();
      }

      put(relativeUrl) {
        this.request =  executeRawRequest('PUT', relativeUrl, bodyBuilderPut(this.options), this.options);
        return this.treat();
      }

      treat() {
        return this.request
          // Enrich the objects
          .then(
            response => {
              if (response.ok) {
                return response.json()
                  .then(json => {
                    if (json._offline) {
                      return json;
                    }
                    return json;
                  });
              }

              if (this.options.listOfAcceptableHttpStatusCode.indexOf(response.status) >= 0) {
                // We have an unacceptable error
                return response;
              }

              let message = "Error";
              switch(response.status) {
                case 401: // Not-Authorized - you need to login first
                  location.hash = "#/login";
                  break;

                case 403: // Forbidden, show a "Not authorized message"
                  message = "Forbidden";
                  break;

                case 404: // Not found
                  message = "Not found";
                  break;

                case 500: // Internal server error - let's show a ugly error box to the developper
                default:
                  message = "#" + response.status + ": Internal server error";
                  console.error("InternalJS.executeRawRequest: ", response);
                  break;
              }

              throw message;
            },
            error   => {
              console.error("InternalJS.executeRawRequest/catch: ", error);
              throw "Server unreachable. Please check your network connection.";
            }
          )
          .catch(error => {
            console.error("dataService - catched and rethrown error: ", error);
            if (this.onError) {
              return this.onError(error);
            }
            throw error;
          })
      }
    }

    Polymer({
      is: 'cryptomedic-data-service',

      // https://www.polymer-project.org/1.0/docs/devguide/properties
      properties: {
      },

      listeners: {
        'logout.tap': 'doLogout'
      },

      // ready() {
      // },

      attached() {
        this.remaining = false;
        this.username = false;
        window.dataService = this;
        // Let's check the login directly
        this.doLoginCheck();
      },

      treatAuthenticationResponse: function(data) {
        if (!window.cryptomedic) {
          window.cryptomedic = {};
        }
        window.cryptomedic.serverSettings = data;

        // .then(worker.post.bind(this, 'init'))

        if (location.hash == "#/login") {
          location.hash = "#/home";
        }

        this.username = data.username;

        return data;
      },

      checkOfflineData: function(json) {
        if (!json._offline) {
          return json;
        }

        let finished = Promise.resolve();

        let offline = json._offline;
        delete(json._offline);

        if (offline.reset) {
          finished = finished.then(() => db.clear());
        }

        // Run around the offline data, but after all this, send back the ORIGINAL json for treatment...
        offline.data = offline.data.sort(sortRecordByTimestamp);

        for(let rec of offline.data) {
          // Bind to keep the actual value of "rec"
          finished = finished.then(db.triageLine.bind(db, rec))
        }

        // If remaining, let's ask for them !!!
        this.remaining = offline.remaining;
        if (this.remaining == 0) {
          this.remaining = false;
        }
        if (offline.remaining) {
          console.log("remaining: ", offline.remaining);
          finished = finished.then(() => {
            console.log("Sync again");

            // This is not binded to what I hoped...
            this.doSync();
          });
        } else {
          console.log("finished");
        }

        // Return final response with original data:
        return finished.then(() => {
          return json;
        });
      },

      doLoginCheck() {
        return (new OneRequest())
          .setData({
            'computerId': localStorage.cryptomedicComputerId
          })
          .get('auth/settings')
          .then((json) => this.treatAuthenticationResponse(json))
          .then((json) => this.checkOfflineData(json))
          .catch(() => {})
          ;
      },

      doLogin(username, password) {
        return (new OneRequest())
          .setData({
            'username': username,
            'password': password,
            'computerId': localStorage.cryptomedicComputerId
          })
          .post('auth/mylogin')
          .then((json) => this.treatAuthenticationResponse(json))
          .then((json) => this.checkOfflineData(json))
          .catch((error) => {
            console.error("doLogin: ", error);
          })
          ;
      },

      /*
       * Simply get the next data
       *
       */
      doSync() {
        return (new OneRequest())
          .get('sync')
          .then((json) => this.checkOfflineData(json))
          ;
      },

      doResync() {
        localStorage.syncCheckpoint = "";
        return this.doSync();
      },

      doLogout() {
        return (new OneRequest())
          .get('auth/logout')
          .then(() => {
            window.cryptomedic.serverSettings = {};
            location.hash = "/login";
            this.username = false;
            this.remaining = false;
          })
          ;
      },

      getFolder(id) {
        let finished = Promise.resolve();
        // if (this.remaining) {
        if (true) {
          // We are not finished, let's get the info from the server
          finished = finished.then(() => {
            return (new OneRequest())
              .get('folder/' + id)

              .then(json => {
                // Do this after asynchronously
                background(this.checkOfflineData, json);
                return json.folder;
              })
          });
        }

        // If no data available, look in the local database

        return finished;
      },

      createFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel(), init: { method: 'POST' }, data: nullify(data)})
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      saveFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel() + '/' + data['id'], init: { method: 'PUT' }, data: nullify(data) })
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      deleteFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel() + '/' + data['id'], init: { method: 'DELETE' }})
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      unlockFile(data) {
        // return myFrontFetch({ url: 'unfreeze/' + data.getModel() + '/' + data['id'] })
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },
      'getReport': function(reportName, data) {
        // return myFrontFetch({ url: 'reports/' + reportName, data: nullify(data) })
        //   .catch()
        //   ;
      },

      'searchForPatients': function(params) {
        // return myFrontFetch({ url: 'folder', data: params })
        //   .then(function(data) {
        //     var list = [];
        //     for(var i in data) {
        //       list.push(new Patient(data[i]));
        //     }
        //     return list;
        //   })
        //   .then(function(data) {
        //     for(var i in data) {
        //       data[i] = new Patient(data[i]);
        //     }
        //     return data;
        //   })
        //   .catch()
        //   ;
      },

      // READWRITE
      'createReference': function(year, order) {
        // return myFrontFetch({ url: 'reference', init: { method: 'POST'}, data: {
        //   'entryyear': year,
        //   'entryorder': order
        // }})
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      'usersList': function() {
        // return myFrontFetch({ url: 'users' })
        //   .catch()
        //   ;
      },

      'userAdd': function(user) {
        // return myFrontFetch({ url: 'users' , init: { method: 'POST' }, data: user })
        //   .catch()
        //   ;
      },

      'userDelete': function(id) {
        // return myFrontFetch({ url: 'users/' + id, init: { method: 'DELETE' }})
        //   .catch()
        //   ;
      },

      'userUpdate': function(user) {
        // return myFrontFetch({ url: 'users/' + user.id, init: { method: 'PUT' }, data: user})
        //   .catch()
        //   ;
      },

      'userPassword': function(id, pwd) {
        // return myFrontFetch({ url: 'users/password/' + id, init: { method: 'POST' }, data: { password: pwd }})
        //   .catch()
        //   ;
      }

    })
  })();
  </script>
</dom-module>
