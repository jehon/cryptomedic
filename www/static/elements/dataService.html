<link rel="import" href="../../bower_components/polymer/polymer.html">



<dom-module name="cryptomedic-data-service">
  <template>
    <paper-dialog id='modal'>
      <h2>Oups... {{message}}</h2>
      {{details}}
    </paper-dialog>
  </template>


  <script src="../js/oneRequest.js"></script>
  <script>
  (function() {
    // Build up the cryptomedicComputerId
    if (!localStorage.cryptomedicComputerId) {
      var mask = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      var result = '';
      for (var i = 0; i < 32; i++) {
        result += mask[Math.floor(Math.random() * mask.length)];
      }
      localStorage.cryptomedicComputerId = result;
    }

    //************************************************************************************/
    //**** Body builders according to method
    function bodyBuilderGet(options) {
      return Object.keys(options.data).map(function (keyName) {
        return encodeURIComponent(keyName) + '=' + encodeURIComponent(options.data[keyName]);
      }).join('&')
    }

    function bodyBuilderPost(options) {
      var body = new FormData();
      for(var a in options.data) {
        body.append(a, options.data[a]);
      }
      return body;
    }

    function bodyBuilderPut(options) {
      if (!options.headers) {
        options.headers = {};
      }
      // Thanks to: http://blog.gospodarets.com/fetch_in_action/
      options.headers['Content-type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
      return bodyBuilderGet(options);
    }

    //************************************************************************************/
    /*
     * Proxy to new Request(...).fetch
     *
     * Use get() and post() preferably.
     *
     * @var {Function} executeRawRequest
     * @see internals.get
     * @see internals.post
     *
     */
    function executeRawRequest(method, relativeUrl, body, options) {
      options.fullUrl = '/api/v1.1/' + relativeUrl;

      return fetch(new Request(options.fullUrl, {
        method: method,
        credentials: 'include',
        body: body
      }));
    }

    //************************************************************************************/
    // ***** Public API **********
    class OneRequest {
      constructor(options = {}) {
        this.options = Object.assign({},  {
          context: "Undefined",
          errorMsg: null,
          data: false,
          listOfAcceptableHttpStatusCode: [ ],

          onSuccess: (response) => { return response; },
          onError: (error) => { throw error; },
        }, options);

        this.fired = false;
      }

      setContext(context) {
        this.options.context = context;
        if (!this.options.errorMessage) {
          this.options.errorMessage = context;
        }
        return this;
      }

      setErrorMessage(errorMessage) {
        this.options.errorMessage = errorMessage;
        return this;
      }

      setData(data) {
        this.options.data = data;
        return this;
      }

      setListOfAcceptableHttpStatusCode(list) {
        this.options.listOfAcceptableHttpStatusCode = this.options.listOfAcceptableHttpStatusCode.join(list);
        return this;
      }

      addAcceptableHttpStatusCode(code) {
        this.options.listOfAcceptableHttpStatusCode.push(code);
        return this;
      }

      setOnSuccess(onSuccess) {
        this.options.onSuccess = onSuccess;
        return this;
      }

      setOnError(onError) {
        this.options.onError = onError;
        return this;
      }

      get(relativeUrl) {
        this.request = executeRawRequest('GET', relativeUrl + '?' + bodyBuilderGet(this.options), null, this.options);
        return this.treat();
      }

      post(relativeUrl) {
        this.request =  executeRawRequest('POST', relativeUrl, bodyBuilderPost(this.options), this.options);
        return this.treat();
      }

      put(relativeUrl) {
        this.request =  executeRawRequest('PUT', relativeUrl, bodyBuilderPut(this.options), this.options);
        return this.treat();
      }

      treat() {
        return this.request
          // Enrich the objects
          .then(
            response => {
              console.log(response);
              if (response.ok) {
                return response.json()
                  .then(json => {
                    if (json._offline) {
                      // TODO: treat the offline record
                      console.warn("offline data: ", json._offline);
                      delete(json._offline);
                    }
                    return json;
                  });
              }

              if (this.options.listOfAcceptableHttpStatusCode.indexOf(response.status) >= 0) {
                // We have an unacceptable error
                return response;
              }

              let message = "Error";
              switch(response.status) {
                case 401: // Not-Authorized - you need to login first
                  location.hash = "#/login";
                  break;

                case 403: // Forbidden, show a "Not authorized message"
                  message = "Forbidden";
                  break;

                case 404: // Not found
                  message = "Not found";
                  break;

                case 500: // Internal server error - let's show a ugly error box to the developper
                default:
                  message = "#" + response.status + ": Internal server error";
                  console.error("InternalJS.executeRawRequest: ", response);
                  break;
              }

              throw message;
            },
            error   => {
              console.error("InternalJS.executeRawRequest/catch: ", error);
              throw "Server unreachable. Please check your network connection.";
            }
          )
          .catch(error => {
            console.error(error);
            if (this.onError) {
              return this.onError(error);
            }
            throw error;
          })
      }
    }

    function treatAuthenticationResponse(data) {
      if (!window.cryptomedic) {
        window.cryptomedic = {};
      }
      window.cryptomedic.serverSettings = data;

      // .then(worker.post.bind(this, 'init'))

      if (location.hash == "#/login") {
        location.hash = "#/home";
      }

      return data;
    }

    Polymer({
      is: 'cryptomedic-data-service',

      // https://www.polymer-project.org/1.0/docs/devguide/properties
      properties: {
      },

      attached() {
        window.dataService = this;
      },

      doLoginCheck() {

// TODO: send back a 405, instead of a 401 ???

        return (new OneRequest())
          .setData({
            'computerId': localStorage.cryptomedicComputerId
          })
          .get('auth/settings')
          .then(treatAuthenticationResponse)
          ;
      },

      doLogin(username, password) {
        return (new OneRequest())
          .setData({
            'username': username,
            'password': password,
            'computerId': localStorage.cryptomedicComputerId
          })
          .post('auth/mylogin')
          .then(treatAuthenticationResponse)
          ;
      },

      doLogout() {
        return (new OneRequest())
          .get('auth/logout')
          .then(() => {
            window.cryptomedic.serverSettings = {};
            location.hash = "/login";
          })
          ;

      },

      getFolder(id) {

      },

      createFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel(), init: { method: 'POST' }, data: nullify(data)})
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      saveFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel() + '/' + data['id'], init: { method: 'PUT' }, data: nullify(data) })
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      deleteFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel() + '/' + data['id'], init: { method: 'DELETE' }})
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      unlockFile(data) {
        // return myFrontFetch({ url: 'unfreeze/' + data.getModel() + '/' + data['id'] })
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },


    })
  })();
  </script>
</dom-module>
