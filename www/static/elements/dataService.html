<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module name="cryptomedic-data-service">
  <template>
    <!-- <paper-dialog id='modal'> -->
      <!-- <h2>Oups... {{message}}</h2> -->
      <!-- {{details}} -->
    <!-- </paper-dialog> -->
  </template>

  <script>
  (function() {
    // Build up the cryptomedicComputerId
    if (!localStorage.cryptomedicComputerId) {
      var mask = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      var result = '';
      for (var i = 0; i < 32; i++) {
        result += mask[Math.floor(Math.random() * mask.length)];
      }
      localStorage.cryptomedicComputerId = result;
    }

    let db = new Database();

    //************************************************************************************/
    //**** Body builders according to method
    function bodyBuilderGet(options) {
      return Object.keys(options.data).map(function (keyName) {
        return encodeURIComponent(keyName) + '=' + encodeURIComponent(options.data[keyName]);
      }).join('&')
    }

    function bodyBuilderPost(options) {
      var body = new FormData();
      for(var a in options.data) {
        body.append(a, options.data[a]);
      }
      return body;
    }

    function bodyBuilderPut(options) {
      if (!options.headers) {
        options.headers = {};
      }
      // Thanks to: http://blog.gospodarets.com/fetch_in_action/
      options.headers['Content-type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
      return bodyBuilderGet(options);
    }

    //************************************************************************************/
    /*
     * Proxy to new Request(...).fetch
     *
     * Use get() and post() preferably.
     *
     * @var {Function} executeRawRequest
     * @see internals.get
     * @see internals.post
     *
     */
    function executeRawRequest(method, relativeUrl, body, options) {
      options.fullUrl = '/api/v1.1/' + relativeUrl;

      return fetch(new Request(options.fullUrl,
        Object.assign({}, options.fetchOptions,
          {
            method: method,
            credentials: 'include',
            body: body
          }
        )
      ));
    }

    //************************************************************************************/
    // ***** Public API **********
    class OneRequest {
      constructor(options = {}) {
        this.options = Object.assign({},  {
          context: "Undefined",
          errorMsg: null,
          data: false,
          listOfAcceptableHttpStatusCode: [ ],

          onSuccess: (response) => { return response; },
          onError: (error) => { throw error; },
          fetchOptions: {
            headers: new Headers()
          }
        }, options);

        // Append sync status
        this.options.fetchOptions.headers.append("X-SYNC-CHECKPOINT", localStorage.syncCheckpoint);

        this.fired = false;
      }

      setContext(context) {
        this.options.context = context;
        if (!this.options.errorMessage) {
          this.options.errorMessage = context;
        }
        return this;
      }

      setErrorMessage(errorMessage) {
        this.options.errorMessage = errorMessage;
        return this;
      }

      setData(data) {
        this.options.data = data;
        return this;
      }

      setListOfAcceptableHttpStatusCode(list) {
        this.options.listOfAcceptableHttpStatusCode = this.options.listOfAcceptableHttpStatusCode.join(list);
        return this;
      }

      addAcceptableHttpStatusCode(code) {
        this.options.listOfAcceptableHttpStatusCode.push(code);
        return this;
      }

      setOnSuccess(onSuccess) {
        this.options.onSuccess = onSuccess;
        return this;
      }

      setOnError(onError) {
        this.options.onError = onError;
        return this;
      }

      get(relativeUrl) {
        this.request = executeRawRequest('GET', relativeUrl + '?' + bodyBuilderGet(this.options), null, this.options);
        return this.treat();
      }

      post(relativeUrl) {
        this.request =  executeRawRequest('POST', relativeUrl, bodyBuilderPost(this.options), this.options);
        return this.treat();
      }

      put(relativeUrl) {
        this.request =  executeRawRequest('PUT', relativeUrl, bodyBuilderPut(this.options), this.options);
        return this.treat();
      }

      treat() {
        return this.request
          // Enrich the objects
          .then(
            response => {
              if (response.ok) {
                return response.json()
                  .then(json => {
                    if (json._offline) {
                      return checkOfflineData(json);
                    }
                    return json;
                  });
              }

              if (this.options.listOfAcceptableHttpStatusCode.indexOf(response.status) >= 0) {
                // We have an unacceptable error
                return response;
              }

              let message = "Error";
              switch(response.status) {
                case 401: // Not-Authorized - you need to login first
                  location.hash = "#/login";
                  break;

                case 403: // Forbidden, show a "Not authorized message"
                  message = "Forbidden";
                  break;

                case 404: // Not found
                  message = "Not found";
                  break;

                case 500: // Internal server error - let's show a ugly error box to the developper
                default:
                  message = "#" + response.status + ": Internal server error";
                  console.error("InternalJS.executeRawRequest: ", response);
                  break;
              }

              throw message;
            },
            error   => {
              console.error("InternalJS.executeRawRequest/catch: ", error);
              throw "Server unreachable. Please check your network connection.";
            }
          )
          .catch(error => {
            console.error("dataService - catched and rethrown error: ", error);
            if (this.onError) {
              return this.onError(error);
            }
            throw error;
          })
      }
    }

    function checkOfflineData(json) {
      if (!json._offline) {
        return json;
      }

      let offline = json._offline;
      delete(json._offline);

      // Run around the offline data, but after all this, send back the ORIGINAL json for treatment...
      offline.data = offline.data.sort((a, b) => {
        // -1 => a come first
        if (a.checkpoint == b.checkpoint) {
          return 0;
        }
        if (!a.checkpoint) {
          return 1;
        }
        if (!b.checkpoint) {
          return -1;
        }
        if (a.checkpoint < b.checkpoint) {
          return -1
        }
        return 1;
      });

      let finished = Promise.resolve();
      for(let rec of offline.data) {
        ((rec) => {
          // finished is updated to take into account the new record:
          if (rec.type == "Deleted") {
            finished = finished.then(() => db.deleteInDB(rec.record.entity_type, rec.record.entity_id));
          } else {
            finished = finished.then(() => db.storeInDB(rec['type'], rec.record));
          }
          finished = finished.then(() => db.checkpointInDB(rec.checkpoint));
        })(rec);
      }

      // Return final response with original data:
      return finished.then(() => {
        return json;
      });
    }

    function treatAuthenticationResponse(data) {
      if (!window.cryptomedic) {
        window.cryptomedic = {};
      }
      window.cryptomedic.serverSettings = data;

      // .then(worker.post.bind(this, 'init'))

      if (location.hash == "#/login") {
        location.hash = "#/home";
      }

      return data;
    }

    Polymer({
      is: 'cryptomedic-data-service',

      // https://www.polymer-project.org/1.0/docs/devguide/properties
      properties: {
      },

      attached() {
        window.dataService = this;
      },

      doLoginCheck() {
        return (new OneRequest())
          .setData({
            'computerId': localStorage.cryptomedicComputerId
          })
          .get('auth/settings')
          .then(treatAuthenticationResponse)
          .catch(() => {})
          ;
      },

      doLogin(username, password) {
        return (new OneRequest())
          .setData({
            'username': username,
            'password': password,
            'computerId': localStorage.cryptomedicComputerId
          })
          .post('auth/mylogin')
          .then(treatAuthenticationResponse)
          .catch((error) => {
            console.error("doLogin: ", error);
          })
          ;
      },

      /*
       * Simply get the next data
       *
       */
      doSync() {
        return (new OneRequest())
          .get('sync')
          ;
      },

      doResync() {
        localStorage.syncCheckpoint = "";
        return this.doSync();
      },

      doLogout() {
        return (new OneRequest())
          .get('auth/logout')
          .then(() => {
            window.cryptomedic.serverSettings = {};
            location.hash = "/login";
          })
          ;

      },

      getFolder(id) {
        // if (lastPatientSelected && lastPatientSelected.id == id) {
        //   console.log("reusing old selected patient");
        //   return Promise.resolve(lastPatientSelected);
        // }

        // console.log('Getting the folder live: #' + id);

        // return myFrontFetch({ url: 'folder/' + id })
        //   // Store the received record into the database
        //   .then((json) => (new Database()).storeRecord({ record: json}, false) )
        //   .then((data) => { return new Folder(data); })
        //   .then(folder => { lastPatientSelected = folder; return folder; })
        //   .then((data) => { return dispatch(catalog.FOLDER_UPDATE_FROM_SERVER, data); })
        //   .catch((data) => {
        //     console.log('in error in selectFile', data);
        //     dispatch(catalog.CONNECTION_NOT_FOUND, data);
        //     return null;
        //   })
        //   ;
      },

      createFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel(), init: { method: 'POST' }, data: nullify(data)})
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      saveFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel() + '/' + data['id'], init: { method: 'PUT' }, data: nullify(data) })
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      deleteFile(data) {
        // return myFrontFetch({ url: 'fiche/' + data.getModel() + '/' + data['id'], init: { method: 'DELETE' }})
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },

      unlockFile(data) {
        // return myFrontFetch({ url: 'unfreeze/' + data.getModel() + '/' + data['id'] })
        //   .then(function(data) { return new Folder(data); })
        //   .catch()
        //   ;
      },


    })
  })();
  </script>
</dom-module>
