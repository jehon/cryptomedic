<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="../../bower_components/fetchfull-elements/src/fetchfull-element.html">

<dom-module name="cryptomedic-data-service">
  <template>
    <fetchfull-element id='network'>
      <content></content>
    </fetchfull-element>
  </template>

  <script>
    /* global jQuery, Database, background, API_VERSION */
    (function() {
      let userCb = jQuery.Callbacks();
      // userCb.add((data) => {
      //   console.log("User callback: ", data);
      // });

      let syncRemaining = false;
      let syncRemainingCb = jQuery.Callbacks();
      syncRemainingCb.add((data) => {
        // Store the information locally at least
        syncRemaining = data;
      });

      // Debug
      syncRemainingCb.add((data) => {
        console.info("syncRemaining callback: ", data);
      });

      // Build up the cryptomedicComputerId
      if (!localStorage.cryptomedicComputerId) {
        var mask = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        var result = '';
        for (var i = 0; i < 32; i++) {
          result += mask[Math.floor(Math.random() * mask.length)];
        }
        localStorage.cryptomedicComputerId = result;
      }

      if (!localStorage.syncCheckpoint) {
        localStorage.syncCheckpoint = "";
      }

      let db = new Database();

      let currentlySyncing = false;

      window.cryptomedic = {};
      window.cryptomedic.serverSettings = {};

      Polymer({
        is: 'cryptomedic-data-service',

        properties: {},

        ready: function() {
          // Hook in requestToUrl to add the prefix:
          let r = this.$.network.requestToUrl;
          this.$.network.requestToUrl = function(url) {
            return r.call(this, '/api/' + API_VERSION + '/' + url);
          }
        },

        userCb,
        syncRemainingCb,


        /**************************/
        /*** Start              ***/
        /**************************/

        start: function() {
          return this.$.network
            .reset()
            .requestWithCredentials("include")
            .responseAsJson()
            .onResponseCode(401, () => {
              window.location = "#login";
            })
            // This is done async % then...
            .onSuccess(json => {
              // Check offline data
              let finished = Promise.resolve();

              // Do we reset the database?
              if (json._offline && json._offline.reset) {
                finished = finished.then(() => db.clear());
              }

              // Put ONLINE data
              if (typeof(json.online) != "undefined") {
                finished = finished.then(() => {
                  return db.triageList(json.online, false);
                })
              }

              // Put OFFLINE data
              if (typeof(json._offline) != "undefined") {
                finished = finished.then(() => {
                  return db.triageList(json._offline.data, true);
                })
                .then(() => {
                  // Store the final checkpoint
                  // in case the last line is also present in online, and thus pruned
                  // by the optimization...

                  return db.checkpointInDB(json._offline.checkpoint);

                }).then(() => {
                  // Adapt remaining /Xor/ launch new sync

                  if (json._offline.remaining) {
                    // This is not binded to what I hoped...
                    console.log("Triage: syncRemaining: TODO - syncing again disabled");
                    // TODO: how to continue syncing with or without background???
                    // background(() => { this.doSync() });
                  } else {
                    syncRemaining = false;
                  }
                  syncRemainingCb.fire(json._offline.remaining);
                });
              }

              // Return final response with original data:
              return finished.then(() => {
                return json;
              });
            });
        },

        /**************************/
        /*** Authentication     ***/
        /**************************/

        doLoginCheck() {
          return this.start()
            .requestWithGet()
            .requestToUrl('auth/settings')
            .requestWithData({
              'computerId': localStorage.cryptomedicComputerId
            })
            .onResponseCode(404, () => {
              return false;
            })
            .then(userCb.fire)
            ;
        },

        doLogin(username, password) {
          return this.start()
            .requestWithPost()
            .requestToUrl('auth/mylogin')
            .requestWithData({
              'username': username,
              'password': password,
              'computerId': localStorage.cryptomedicComputerId
            })
            .then(userCb.fire)
            ;
        },

        /*
         * Simply get the next data
         *
         */
        doSync() {
          // Avoid having two syncing going on in parallel
          if (currentlySyncing) {
            console.info("Already syncing, not doing it again");
          }
          currentlySyncing = true;
          return this.start()
            .requestWithGet()
            .requestToUrl('sync')
            .then((json) => { currentlySyncing = false; return json; })
            ;
        },

        doResync() {
          localStorage.syncCheckpoint = "";
          return this.doSync();
        },

        doLogout(localOnly = false) {
          let finished = Promise.resolve();

          // localOnly could be the "tap" event, we thus check carefully what we receive
          if (localOnly !== true) {
            finished = finished.then(() => {
              return this.start()
                .requestWithGet()
                .requestToUrl('auth/logout');
            });
          }
          finished.then(() => {
            userCb.fire(null);
            syncRemainingCb.fire(false);

          })
          ;
        },

        /**************************/
        /*** Patient            ***/
        /**************************/

        'searchForPatients': function(params) {
          return this.start()
            .requestWithGet()
            .requestWithData(params)
            .requestToUrl('folder')
            .then(function(data) {
              var list = [];
              for(var i in data) {
                list.push(new Patient(data[i]));
              }
              return list;
            })
        },

        'checkReference': function(year, order) {
          return new Promise((resolve, reject) => {
            this.start()
              .requestWithGet()
              .requestToUrl('reference/' + year + '/' + order)
              .onResponseCode(404, () => {
                resolve(false);
              })
              .then(data => {
                resolve(data);
              })
              .catch((error) => {
                reject(error);
                throw error;
              })
          });
        },

        'createReference': function(year, order) {
          return this.start()
            .requestToUrl('reference')
            .requestWithPost()
            .requestWithData({
              'entryyear': year,
              'entryorder': order
            })
        },

        getFolder(id) {
          console.log("GetFolder on ", id, typeof(id));

// How to cache getFolder for 1 minute if no change is made???
// Should be stored in database + flag for getting it in db even if not synced

          let finished = Promise.resolve();

          // TODO
          // if (syncRemaining) {
          if (true) {
            // We are not finished, let's get the info from the server
            finished = finished.then(() => {
              return this.start()
                .requestWithGet()
                .requestToUrl('folder/' + id)
                .then(json => {
                  return json.online;
                })
            });
          }

          // If no data available, look in the local database
          finished = finished.then(() => {
            return db.getFolder(id)
              .then(f => {
                return f;
              })
              ;
          })

          // Build up the object
          finished = finished.then(json => {
            /* global Folder */
            let folder = new Folder();
            for(let line of json) {
              if (line.getModel() == "Patient") {
                 /* global Patient */
                folder.setMainFile(line);
              } else {
                folder.addSubFile(line);
              }
            }
            folder.sort();
            console.log("Folder built up: ", folder);
            return folder;
          })

          return finished;
        },

        /**************************/
        /*** Patient - File     ***/
        /**************************/

        createFile(data) {
          return this.start()
            .requestWithPost()
            .requestToUrl('fiche/' + data.getModel())
            .requestWithData(nullify(data))
            .then(function(data) {
              return new Folder(data);
            })
            ;
        },

        saveFile(data) {
          return this.start()
            .requestWithPut()
            .requestToUrl('fiche/' + data.getModel() + '/' + data['id'])
            .requestWithData(nullify(data))
            .then(function(data) { return new Folder(data); })
            ;
        },

        deleteFile(data) {
          return this.start()
            .requestWithDelete()
            .requestToUrl('fiche/' + data.getModel() + '/' + data['id'])
            .then(function(data) { return new Folder(data); })
            ;
        },

        unlockFile(data) {
          return this.start()
            .requestWithGet()
            .requestToUrl('unfreeze/' + data.getModel() + '/' + data['id'])
            .then(function(data) { return new Folder(data); })
            ;
        },

        /***********************/
        /*** Report          ***/
        /***********************/

        'getReport': function(reportName, data) {
          return this.start()
            .requestWithGet()
            /* global nullify */
            .requestWithData(nullify(data))
            .requestToUrl('reports/' + reportName)
        },

        /***********************/
        /*** User management ***/
        /***********************/

        'usersList': function() {
          return this.start()
            .requestWithGet()
            .requestToUrl('users')
        },

        'userAdd': function(user) {
          return this.start()
            .requestWithPost()
            .requestToUrl('users')
            .requestWithData(user)
        },

// Check here:
        'userDelete': function(id) {
          return this.start()
            .requestWithDelete()
            .requestToUrl('users/' + id)
        },

// Check here:
        'userUpdate': function(user) {
          return this.start()
            .requestWithPut()
            .requestToUrl('users/' + user.id)
            .requestWithData(user)
        },

// Check here:
        'userPassword': function(id, pwd) {
          return this.start()
            .requestWithPost()
            .requestWithData({ password: pwd })
            .requestToUrl('users/password/' + id)
        }
      })
    })();
  </script>
</dom-module>
